--- a/components/webcrypto/algorithm_dispatch.cc	2016-02-25 15:03:55.390959047 +0000
+++ b/components/webcrypto/algorithm_dispatch.cc	2016-02-25 15:04:27.693425660 +0000
@@ -6,12 +6,12 @@
 
 #include "base/logging.h"
 #include "components/webcrypto/algorithm_implementation.h"
-#include "components/webcrypto/algorithm_implementations.h"
 #include "components/webcrypto/algorithm_registry.h"
 #include "components/webcrypto/crypto_data.h"
 #include "components/webcrypto/generate_key_result.h"
+#include "components/webcrypto/platform_crypto.h"
 #include "components/webcrypto/status.h"
-#include "crypto/openssl_util.h"
+#include "components/webcrypto/webcrypto_util.h"
 #include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
 
 namespace webcrypto {
@@ -230,7 +230,7 @@
   // information about the plaintext of the encrypted key (for instance the JWK
   // key_ops). As long as the ImportKey error messages don't describe actual
   // key bytes however this should be OK. For more discussion see
-  // http://crbug.com/372040
+  // http://crubg.com/372040
   return ImportKey(format, CryptoData(buffer), algorithm, extractable, usages,
                    key);
 }
@@ -309,8 +309,8 @@
 
 scoped_ptr<blink::WebCryptoDigestor> CreateDigestor(
     blink::WebCryptoAlgorithmId algorithm) {
-  crypto::EnsureOpenSSLInit();
-  return CreateDigestorImplementation(algorithm);
+  PlatformInit();
+  return CreatePlatformDigestor(algorithm);
 }
 
 bool SerializeKeyForClone(const blink::WebCryptoKey& key,
--- a/components/webcrypto/algorithm_implementation.cc	2016-02-25 15:05:44.878540527 +0000
+++ b/components/webcrypto/algorithm_implementation.cc	2016-02-25 15:39:20.079666584 +0000
@@ -4,7 +4,6 @@
 
 #include "components/webcrypto/algorithm_implementation.h"
 
-#include "components/webcrypto/blink_key_handle.h"
 #include "components/webcrypto/status.h"
 
 namespace webcrypto {
@@ -182,8 +181,7 @@
 Status AlgorithmImplementation::SerializeKeyForClone(
     const blink::WebCryptoKey& key,
     blink::WebVector<uint8_t>* key_data) const {
-  *key_data = GetSerializedKeyData(key);
-  return Status::Success();
+  return Status::ErrorUnsupported();
 }
 
 Status AlgorithmImplementation::DeserializeKeyForClone(
--- a/components/webcrypto/algorithm_implementation.h	2016-02-25 15:40:14.447453381 +0000
+++ b/components/webcrypto/algorithm_implementation.h	2016-02-25 15:40:32.800718960 +0000
@@ -36,10 +36,6 @@
 //   * The key usages have already been verified. In fact in the case of calls
 //     to Encrypt()/Decrypt() the corresponding key usages may not be present
 //     (when wrapping/unwrapping).
-//
-// An AlgorithmImplementation can also assume that
-// crypto::EnsureOpenSSLInit() will be called before any of its
-// methods are invoked (except the constructor).
 class AlgorithmImplementation {
  public:
   virtual ~AlgorithmImplementation();
@@ -208,11 +204,9 @@
   //
   // Tests to verify structured cloning are available in:
   //   LayoutTests/crypto/clone-*.html
-
-  // Note that SerializeKeyForClone() is not virtual because all
-  // implementations end up doing the same thing.
-  Status SerializeKeyForClone(const blink::WebCryptoKey& key,
-                              blink::WebVector<uint8_t>* key_data) const;
+  virtual Status SerializeKeyForClone(
+      const blink::WebCryptoKey& key,
+      blink::WebVector<uint8_t>* key_data) const;
 
   virtual Status DeserializeKeyForClone(
       const blink::WebCryptoKeyAlgorithm& algorithm,
--- a/components/webcrypto/algorithm_registry.cc	2016-02-25 15:43:23.503189274 +0000
+++ b/components/webcrypto/algorithm_registry.cc	2016-02-25 15:44:20.664016413 +0000
@@ -6,9 +6,8 @@
 
 #include "base/lazy_instance.h"
 #include "components/webcrypto/algorithm_implementation.h"
-#include "components/webcrypto/algorithm_implementations.h"
+#include "components/webcrypto/platform_crypto.h"
 #include "components/webcrypto/status.h"
-#include "crypto/openssl_util.h"
 
 namespace webcrypto {
 
@@ -18,20 +17,20 @@
 class AlgorithmRegistry {
  public:
   AlgorithmRegistry()
-      : sha_(CreateShaImplementation()),
-        aes_gcm_(CreateAesGcmImplementation()),
-        aes_cbc_(CreateAesCbcImplementation()),
-        aes_ctr_(CreateAesCtrImplementation()),
-        aes_kw_(CreateAesKwImplementation()),
-        hmac_(CreateHmacImplementation()),
-        rsa_ssa_(CreateRsaSsaImplementation()),
-        rsa_oaep_(CreateRsaOaepImplementation()),
-        rsa_pss_(CreateRsaPssImplementation()),
-        ecdsa_(CreateEcdsaImplementation()),
-        ecdh_(CreateEcdhImplementation()),
-        hkdf_(CreateHkdfImplementation()),
-        pbkdf2_(CreatePbkdf2Implementation()) {
-    crypto::EnsureOpenSSLInit();
+      : sha_(CreatePlatformShaImplementation()),
+        aes_gcm_(CreatePlatformAesGcmImplementation()),
+        aes_cbc_(CreatePlatformAesCbcImplementation()),
+        aes_ctr_(CreatePlatformAesCtrImplementation()),
+        aes_kw_(CreatePlatformAesKwImplementation()),
+        hmac_(CreatePlatformHmacImplementation()),
+        rsa_ssa_(CreatePlatformRsaSsaImplementation()),
+        rsa_oaep_(CreatePlatformRsaOaepImplementation()),
+        rsa_pss_(CreatePlatformRsaPssImplementation()),
+        ecdsa_(CreatePlatformEcdsaImplementation()),
+        ecdh_(CreatePlatformEcdhImplementation()),
+        hkdf_(CreatePlatformHkdfImplementation()),
+        pbkdf2_(CreatePlatformPbkdf2Implementation()) {
+    PlatformInit();
   }
 
   const AlgorithmImplementation* GetAlgorithm(
--- a/components/webcrypto/crypto_data.cc	2016-02-25 15:45:12.870771831 +0000
+++ b/components/webcrypto/crypto_data.cc	2016-02-25 15:45:30.296023960 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "components/webcrypto/crypto_data.h"
+#include "base/stl_util.h"
 
 namespace webcrypto {
 
@@ -15,7 +16,8 @@
 
 CryptoData::CryptoData(const std::vector<unsigned char>& bytes)
     : bytes_(bytes.data()),
-      byte_length_(static_cast<unsigned int>(bytes.size())) {}
+      byte_length_(static_cast<unsigned int>(bytes.size())) {
+}
 
 CryptoData::CryptoData(const std::string& bytes)
     : bytes_(bytes.size() ? reinterpret_cast<const unsigned char*>(bytes.data())
--- a/components/webcrypto/jwk.cc	2016-02-25 15:47:00.799333414 +0000
+++ b/components/webcrypto/jwk.cc	2016-02-25 15:48:10.118336296 +0000
@@ -6,15 +6,20 @@
 
 #include <set>
 
-#include "base/base64url.h"
+#include "base/base64.h"
 #include "base/json/json_reader.h"
 #include "base/json/json_writer.h"
 #include "base/stl_util.h"
 #include "base/strings/string_piece.h"
 #include "base/strings/stringprintf.h"
-#include "components/webcrypto/algorithms/util.h"
 #include "components/webcrypto/crypto_data.h"
 #include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+
+// TODO(eroman): The algorithm-specific logic in this file for AES and RSA
+// should be moved into the corresponding AlgorithmImplementation file. It
+// exists in this file to avoid duplication between OpenSSL and NSS
+// implementations.
 
 // JSON Web Key Format (JWK) is defined by:
 // http://tools.ietf.org/html/draft-ietf-jose-json-web-key
@@ -283,13 +288,8 @@
   if (status.IsError())
     return status;
 
-  // The JSON web signature spec says that padding is omitted.
-  // https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-36#section-2
-  if (!base::Base64UrlDecode(base64_string,
-                             base::Base64UrlDecodePolicy::DISALLOW_PADDING,
-                             result)) {
+  if (!Base64DecodeUrlSafe(base64_string, result))
     return Status::ErrorJwkBase64Decode(member_name);
-  }
 
   return Status::Success();
 }
@@ -362,15 +362,9 @@
 
 void JwkWriter::SetBytes(const std::string& member_name,
                          const CryptoData& value) {
-  // The JSON web signature spec says that padding is omitted.
-  // https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-36#section-2
-  std::string base64url_encoded;
-  base::Base64UrlEncode(
-      base::StringPiece(reinterpret_cast<const char*>(value.bytes()),
-                        value.byte_length()),
-      base::Base64UrlEncodePolicy::OMIT_PADDING, &base64url_encoded);
-
-  dict_.SetString(member_name, base64url_encoded);
+  dict_.SetString(member_name, Base64EncodeUrlSafe(base::StringPiece(
+                                   reinterpret_cast<const char*>(value.bytes()),
+                                   value.byte_length())));
 }
 
 void JwkWriter::ToJson(std::vector<uint8_t>* utf8_bytes) const {
@@ -379,6 +373,242 @@
   utf8_bytes->assign(json.begin(), json.end());
 }
 
+Status ReadSecretKeyNoExpectedAlg(const CryptoData& key_data,
+                                  bool expected_extractable,
+                                  blink::WebCryptoKeyUsageMask expected_usages,
+                                  std::vector<uint8_t>* raw_key_data,
+                                  JwkReader* jwk) {
+  Status status = jwk->Init(key_data, expected_extractable, expected_usages,
+                            "oct", std::string());
+  if (status.IsError())
+    return status;
+
+  std::string jwk_k_value;
+  status = jwk->GetBytes("k", &jwk_k_value);
+  if (status.IsError())
+    return status;
+  raw_key_data->assign(jwk_k_value.begin(), jwk_k_value.end());
+
+  return Status::Success();
+}
+
+void WriteSecretKeyJwk(const CryptoData& raw_key_data,
+                       const std::string& algorithm,
+                       bool extractable,
+                       blink::WebCryptoKeyUsageMask usages,
+                       std::vector<uint8_t>* jwk_key_data) {
+  JwkWriter writer(algorithm, extractable, usages, "oct");
+  writer.SetBytes("k", raw_key_data);
+  writer.ToJson(jwk_key_data);
+}
+
+Status ReadSecretKeyJwk(const CryptoData& key_data,
+                        const std::string& expected_alg,
+                        bool expected_extractable,
+                        blink::WebCryptoKeyUsageMask expected_usages,
+                        std::vector<uint8_t>* raw_key_data) {
+  JwkReader jwk;
+  Status status = ReadSecretKeyNoExpectedAlg(
+      key_data, expected_extractable, expected_usages, raw_key_data, &jwk);
+  if (status.IsError())
+    return status;
+  return jwk.VerifyAlg(expected_alg);
+}
+
+std::string MakeJwkAesAlgorithmName(const std::string& suffix,
+                                    size_t keylen_bytes) {
+  if (keylen_bytes == 16)
+    return std::string("A128") + suffix;
+  if (keylen_bytes == 24)
+    return std::string("A192") + suffix;
+  if (keylen_bytes == 32)
+    return std::string("A256") + suffix;
+  return std::string();
+}
+
+Status ReadAesSecretKeyJwk(const CryptoData& key_data,
+                           const std::string& algorithm_name_suffix,
+                           bool expected_extractable,
+                           blink::WebCryptoKeyUsageMask expected_usages,
+                           std::vector<uint8_t>* raw_key_data) {
+  JwkReader jwk;
+  Status status = ReadSecretKeyNoExpectedAlg(
+      key_data, expected_extractable, expected_usages, raw_key_data, &jwk);
+  if (status.IsError())
+    return status;
+
+  bool has_jwk_alg;
+  std::string jwk_alg;
+  status = jwk.GetAlg(&jwk_alg, &has_jwk_alg);
+  if (status.IsError())
+    return status;
+
+  if (has_jwk_alg) {
+    std::string expected_algorithm_name =
+        MakeJwkAesAlgorithmName(algorithm_name_suffix, raw_key_data->size());
+
+    if (jwk_alg != expected_algorithm_name) {
+      // Give a different error message if the key length was wrong.
+      if (jwk_alg == MakeJwkAesAlgorithmName(algorithm_name_suffix, 16) ||
+          jwk_alg == MakeJwkAesAlgorithmName(algorithm_name_suffix, 24) ||
+          jwk_alg == MakeJwkAesAlgorithmName(algorithm_name_suffix, 32)) {
+        return Status::ErrorJwkIncorrectKeyLength();
+      }
+      return Status::ErrorJwkAlgorithmInconsistent();
+    }
+  }
+
+  return Status::Success();
+}
+
+// Writes an RSA public key to a JWK dictionary
+void WriteRsaPublicKeyJwk(const CryptoData& n,
+                          const CryptoData& e,
+                          const std::string& algorithm,
+                          bool extractable,
+                          blink::WebCryptoKeyUsageMask usages,
+                          std::vector<uint8_t>* jwk_key_data) {
+  JwkWriter writer(algorithm, extractable, usages, "RSA");
+  writer.SetBytes("n", n);
+  writer.SetBytes("e", e);
+  writer.ToJson(jwk_key_data);
+}
+
+// Writes an RSA private key to a JWK dictionary
+void WriteRsaPrivateKeyJwk(const CryptoData& n,
+                           const CryptoData& e,
+                           const CryptoData& d,
+                           const CryptoData& p,
+                           const CryptoData& q,
+                           const CryptoData& dp,
+                           const CryptoData& dq,
+                           const CryptoData& qi,
+                           const std::string& algorithm,
+                           bool extractable,
+                           blink::WebCryptoKeyUsageMask usages,
+                           std::vector<uint8_t>* jwk_key_data) {
+  JwkWriter writer(algorithm, extractable, usages, "RSA");
+
+  writer.SetBytes("n", n);
+  writer.SetBytes("e", e);
+  writer.SetBytes("d", d);
+  // Although these are "optional" in the JWA, WebCrypto spec requires them to
+  // be emitted.
+  writer.SetBytes("p", p);
+  writer.SetBytes("q", q);
+  writer.SetBytes("dp", dp);
+  writer.SetBytes("dq", dq);
+  writer.SetBytes("qi", qi);
+  writer.ToJson(jwk_key_data);
+}
+
+JwkRsaInfo::JwkRsaInfo() : is_private_key(false) {
+}
+
+JwkRsaInfo::~JwkRsaInfo() {
+}
+
+Status ReadRsaKeyJwk(const CryptoData& key_data,
+                     const std::string& expected_alg,
+                     bool expected_extractable,
+                     blink::WebCryptoKeyUsageMask expected_usages,
+                     JwkRsaInfo* result) {
+  JwkReader jwk;
+  Status status = jwk.Init(key_data, expected_extractable, expected_usages,
+                           "RSA", expected_alg);
+  if (status.IsError())
+    return status;
+
+  // An RSA public key must have an "n" (modulus) and an "e" (exponent) entry
+  // in the JWK, while an RSA private key must have those, plus at least a "d"
+  // (private exponent) entry.
+  // See http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-18,
+  // section 6.3.
+  status = jwk.GetBigInteger("n", &result->n);
+  if (status.IsError())
+    return status;
+  status = jwk.GetBigInteger("e", &result->e);
+  if (status.IsError())
+    return status;
+
+  result->is_private_key = jwk.HasMember("d");
+  if (!result->is_private_key)
+    return Status::Success();
+
+  status = jwk.GetBigInteger("d", &result->d);
+  if (status.IsError())
+    return status;
+
+  // The "p", "q", "dp", "dq", and "qi" properties are optional in the JWA
+  // spec. However they are required by Chromium's WebCrypto implementation.
+
+  status = jwk.GetBigInteger("p", &result->p);
+  if (status.IsError())
+    return status;
+
+  status = jwk.GetBigInteger("q", &result->q);
+  if (status.IsError())
+    return status;
+
+  status = jwk.GetBigInteger("dp", &result->dp);
+  if (status.IsError())
+    return status;
+
+  status = jwk.GetBigInteger("dq", &result->dq);
+  if (status.IsError())
+    return status;
+
+  status = jwk.GetBigInteger("qi", &result->qi);
+  if (status.IsError())
+    return status;
+
+  return Status::Success();
+}
+
+const char* GetJwkHmacAlgorithmName(blink::WebCryptoAlgorithmId hash) {
+  switch (hash) {
+    case blink::WebCryptoAlgorithmIdSha1:
+      return "HS1";
+    case blink::WebCryptoAlgorithmIdSha256:
+      return "HS256";
+    case blink::WebCryptoAlgorithmIdSha384:
+      return "HS384";
+    case blink::WebCryptoAlgorithmIdSha512:
+      return "HS512";
+    default:
+      return NULL;
+  }
+}
+
+bool Base64DecodeUrlSafe(const std::string& input, std::string* output) {
+  // The JSON web signature spec specifically says that padding is omitted.
+  if (input.find_first_of("+/=") != std::string::npos)
+    return false;
+
+  std::string base64_encoded_text(input);
+  std::replace(base64_encoded_text.begin(), base64_encoded_text.end(), '-',
+               '+');
+  std::replace(base64_encoded_text.begin(), base64_encoded_text.end(), '_',
+               '/');
+  base64_encoded_text.append((4 - base64_encoded_text.size() % 4) % 4, '=');
+  return base::Base64Decode(base64_encoded_text, output);
+}
+
+std::string Base64EncodeUrlSafe(const base::StringPiece& input) {
+  std::string output;
+  base::Base64Encode(input, &output);
+  std::replace(output.begin(), output.end(), '+', '-');
+  std::replace(output.begin(), output.end(), '/', '_');
+  output.erase(std::remove(output.begin(), output.end(), '='), output.end());
+  return output;
+}
+
+std::string Base64EncodeUrlSafe(const std::vector<uint8_t>& input) {
+  const base::StringPiece string_piece(
+      reinterpret_cast<const char*>(input.data()), input.size());
+  return Base64EncodeUrlSafe(string_piece);
+}
+
 Status GetWebCryptoUsagesFromJwkKeyOpsForTest(
     const base::ListValue* key_ops,
     blink::WebCryptoKeyUsageMask* usages) {
--- a/components/webcrypto/jwk.h	2016-02-25 15:49:16.032289847 +0000
+++ b/components/webcrypto/jwk.h	2016-02-25 15:49:46.600732073 +0000
@@ -8,6 +8,7 @@
 #include <stdint.h>
 #include <vector>
 
+#include "base/strings/string_piece.h"
 #include "base/values.h"
 #include "third_party/WebKit/public/platform/WebCrypto.h"
 
@@ -125,6 +126,117 @@
   base::DictionaryValue dict_;
 };
 
+// Writes a JWK-formatted symmetric key to |jwk_key_data|.
+//  * raw_key_data: The actual key data
+//  * algorithm: The JWK algorithm name (i.e. "alg")
+//  * extractable: The JWK extractability (i.e. "ext")
+//  * usages: The JWK usages (i.e. "key_ops")
+void WriteSecretKeyJwk(const CryptoData& raw_key_data,
+                       const std::string& algorithm,
+                       bool extractable,
+                       blink::WebCryptoKeyUsageMask usages,
+                       std::vector<uint8_t>* jwk_key_data);
+
+// Parses a UTF-8 encoded JWK (key_data), and extracts the key material to
+// |*raw_key_data|. Returns Status::Success() on success, otherwise an error.
+// In order for this to succeed:
+//   * expected_alg must match the JWK's "alg", if present.
+//   * expected_extractable must be consistent with the JWK's "ext", if
+//     present.
+//   * expected_usages must be a subset of the JWK's "key_ops" if present.
+Status ReadSecretKeyJwk(const CryptoData& key_data,
+                        const std::string& expected_alg,
+                        bool expected_extractable,
+                        blink::WebCryptoKeyUsageMask expected_usages,
+                        std::vector<uint8_t>* raw_key_data);
+
+// Creates an AES algorithm name for the given key size (in bytes). For
+// instance "A128CBC" is the result of suffix="CBC", keylen_bytes=16.
+std::string MakeJwkAesAlgorithmName(const std::string& suffix,
+                                    size_t keylen_bytes);
+
+// This is very similar to ReadSecretKeyJwk(), except instead of specifying an
+// absolute "expected_alg", the suffix for an AES algorithm name is given
+// (See MakeJwkAesAlgorithmName() for an explanation of what the suffix is).
+//
+// This is because the algorithm name for AES keys is dependent on the length
+// of the key. This function expects key lengths to be either 128, 192, or 256
+// bits.
+Status ReadAesSecretKeyJwk(const CryptoData& key_data,
+                           const std::string& algorithm_name_suffix,
+                           bool expected_extractable,
+                           blink::WebCryptoKeyUsageMask expected_usages,
+                           std::vector<uint8_t>* raw_key_data);
+
+// Writes a JWK-formated RSA public key and saves the result to
+// |*jwk_key_data|.
+void WriteRsaPublicKeyJwk(const CryptoData& n,
+                          const CryptoData& e,
+                          const std::string& algorithm,
+                          bool extractable,
+                          blink::WebCryptoKeyUsageMask usages,
+                          std::vector<uint8_t>* jwk_key_data);
+
+// Writes a JWK-formated RSA private key and saves the result to
+// |*jwk_key_data|.
+void WriteRsaPrivateKeyJwk(const CryptoData& n,
+                           const CryptoData& e,
+                           const CryptoData& d,
+                           const CryptoData& p,
+                           const CryptoData& q,
+                           const CryptoData& dp,
+                           const CryptoData& dq,
+                           const CryptoData& qi,
+                           const std::string& algorithm,
+                           bool extractable,
+                           blink::WebCryptoKeyUsageMask usages,
+                           std::vector<uint8_t>* jwk_key_data);
+
+// Describes the RSA components for a parsed key. The names of the properties
+// correspond with those from the JWK spec. Note that Chromium's WebCrypto
+// implementation does not support multi-primes, so there is no parsed field
+// for othinfo.
+struct JwkRsaInfo {
+  JwkRsaInfo();
+  ~JwkRsaInfo();
+
+  bool is_private_key;
+  std::string n;
+  std::string e;
+  std::string d;
+  std::string p;
+  std::string q;
+  std::string dp;
+  std::string dq;
+  std::string qi;
+};
+
+// Parses a UTF-8 encoded JWK (key_data), and extracts the RSA components to
+// |*result|. Returns Status::Success() on success, otherwise an error.
+// In order for this to succeed:
+//   * expected_alg must match the JWK's "alg", if present.
+//   * expected_extractable must be consistent with the JWK's "ext", if
+//     present.
+//   * expected_usages must be a subset of the JWK's "key_ops" if present.
+Status ReadRsaKeyJwk(const CryptoData& key_data,
+                     const std::string& expected_alg,
+                     bool expected_extractable,
+                     blink::WebCryptoKeyUsageMask expected_usages,
+                     JwkRsaInfo* result);
+
+const char* GetJwkHmacAlgorithmName(blink::WebCryptoAlgorithmId hash);
+
+// This decodes JWK's flavor of base64 encoding, as described by:
+// https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-36#section-2
+//
+// In essence it is RFC 4648 'base64url' encoding where padding is omitted.
+bool Base64DecodeUrlSafe(const std::string& input, std::string* output);
+
+// Encodes |input| using JWK's flavor of base64 encoding. See the description
+// above for details.
+std::string Base64EncodeUrlSafe(const base::StringPiece& input);
+std::string Base64EncodeUrlSafe(const std::vector<uint8_t>& input);
+
 // Converts a JWK "key_ops" array to the corresponding WebCrypto usages. Used by
 // testing.
 Status GetWebCryptoUsagesFromJwkKeyOpsForTest(
--- a/components/webcrypto/status.cc	2016-02-25 15:51:15.857023204 +0000
+++ b/components/webcrypto/status.cc	2016-02-25 15:51:28.696208926 +0000
@@ -351,11 +351,6 @@
       "No length was specified for the PBKDF2 Derive Bits operation.");
 }
 
-Status Status::ErrorPbkdf2Iterations0() {
-  return Status(blink::WebCryptoErrorTypeOperation,
-                "PBKDF2 requires iterations > 0");
-}
-
 Status::Status(blink::WebCryptoErrorType error_type,
                const std::string& error_details_utf8)
     : type_(TYPE_ERROR),
--- a/components/webcrypto/status.h	2016-02-25 15:51:57.151620533 +0000
+++ b/components/webcrypto/status.h	2016-02-25 15:52:03.767716235 +0000
@@ -134,7 +134,7 @@
   // Attempted to generate an AES key with an invalid length.
   static Status ErrorGenerateAesKeyLength();
 
-  // 192-bit AES keys are valid, however unsupported (http://crbug.com/533699)
+  // 192-bit AES keys are valid, however unsupported.
   static Status ErrorAes192BitUnsupported();
 
   // The wrong key was used for the operation. For instance, a public key was
@@ -265,9 +265,6 @@
   // No length parameter was provided for PBKDF2's Derive Bits operation.
   static Status ErrorPbkdf2DeriveBitsLengthNotSpecified();
 
-  // PBKDF2 was called with iterations == 0.
-  static Status ErrorPbkdf2Iterations0();
-
  private:
   enum Type { TYPE_ERROR, TYPE_SUCCESS };
 
--- a/components/webcrypto/webcrypto_impl.cc	2016-02-25 15:54:09.672537301 +0000
+++ b/components/webcrypto/webcrypto_impl.cc	2016-02-25 15:54:23.808741744 +0000
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/scoped_ptr.h"
 #include "base/single_thread_task_runner.h"
+#include "base/stl_util.h"
 #include "base/task_runner.h"
 #include "base/thread_task_runner_handle.h"
 #include "base/threading/sequenced_worker_pool.h"
@@ -18,6 +19,7 @@
 #include "components/webcrypto/crypto_data.h"
 #include "components/webcrypto/generate_key_result.h"
 #include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
 #include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
 #include "third_party/WebKit/public/platform/WebString.h"
 
@@ -61,7 +63,7 @@
 //                 threads is silly.
 //
 // * WebCryptoAlgorithm and WebCryptoKey are threadsafe (however the key's
-//   handle(), which wraps an OpenSSL type, may not be and should only be
+//   handle(), which wraps an NSS/OpenSSL type, may not be and should only be
 //   used from the webcrypto thread).
 //
 // * blink::WebCryptoResult is not threadsafe and should only be operated on
@@ -600,8 +602,8 @@
 
   scoped_ptr<EncryptState> state(
       new EncryptState(algorithm, key, data, data_size, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoEncrypt, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoEncrypt, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -615,8 +617,8 @@
 
   scoped_ptr<DecryptState> state(
       new DecryptState(algorithm, key, data, data_size, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoDecrypt, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoDecrypt, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -643,8 +645,8 @@
 
   scoped_ptr<GenerateKeyState> state(
       new GenerateKeyState(algorithm, extractable, usages, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoGenerateKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoGenerateKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -658,8 +660,8 @@
                               blink::WebCryptoResult result) {
   scoped_ptr<ImportKeyState> state(new ImportKeyState(
       format, key_data, key_data_size, algorithm, extractable, usages, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoImportKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoImportKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -668,8 +670,8 @@
                               const blink::WebCryptoKey& key,
                               blink::WebCryptoResult result) {
   scoped_ptr<ExportKeyState> state(new ExportKeyState(format, key, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoExportKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoExportKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -709,8 +711,8 @@
                             blink::WebCryptoResult result) {
   scoped_ptr<WrapKeyState> state(
       new WrapKeyState(format, key, wrapping_key, wrap_algorithm, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoWrapKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoWrapKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -728,8 +730,8 @@
   scoped_ptr<UnwrapKeyState> state(new UnwrapKeyState(
       format, wrapped_key, wrapped_key_size, wrapping_key, unwrap_algorithm,
       unwrapped_key_algorithm, extractable, usages, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoUnwrapKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoUnwrapKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -740,8 +742,8 @@
                                blink::WebCryptoResult result) {
   scoped_ptr<DeriveBitsState> state(
       new DeriveBitsState(algorithm, base_key, length_bits, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoDeriveBits, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoDeriveBits, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
@@ -757,8 +759,8 @@
   scoped_ptr<DeriveKeyState> state(
       new DeriveKeyState(algorithm, base_key, import_algorithm,
                          key_length_algorithm, extractable, usages, result));
-  if (!CryptoThreadPool::PostTask(
-          FROM_HERE, base::Bind(DoDeriveKey, base::Passed(&state)))) {
+  if (!CryptoThreadPool::PostTask(FROM_HERE,
+                                  base::Bind(DoDeriveKey, base::Passed(&state)))) {
     CompleteWithThreadPoolError(&result);
   }
 }
--- a/components/webcrypto/webcrypto_impl.h	2016-02-25 15:55:45.970930033 +0000
+++ b/components/webcrypto/webcrypto_impl.h	2016-02-25 15:55:55.273064560 +0000
@@ -14,7 +14,7 @@
 namespace webcrypto {
 
 // Wrapper around the Blink WebCrypto asynchronous interface, which forwards to
-// the synchronous OpenSSL implementation.
+// the synchronous platform (NSS or OpenSSL) implementation.
 //
 // WebCryptoImpl is threadsafe.
 //
@@ -23,75 +23,79 @@
  public:
   WebCryptoImpl();
 
-  ~WebCryptoImpl() override;
+  // TODO(eroman): Once Blink and Chromium repositories are merged, use
+  //               "override" in place of virtual.
 
-  void encrypt(const blink::WebCryptoAlgorithm& algorithm,
-               const blink::WebCryptoKey& key,
-               const unsigned char* data,
-               unsigned int data_size,
-               blink::WebCryptoResult result) override;
-  void decrypt(const blink::WebCryptoAlgorithm& algorithm,
-               const blink::WebCryptoKey& key,
-               const unsigned char* data,
-               unsigned int data_size,
-               blink::WebCryptoResult result) override;
-  void digest(const blink::WebCryptoAlgorithm& algorithm,
-              const unsigned char* data,
-              unsigned int data_size,
-              blink::WebCryptoResult result) override;
-  void generateKey(const blink::WebCryptoAlgorithm& algorithm,
-                   bool extractable,
-                   blink::WebCryptoKeyUsageMask usages,
-                   blink::WebCryptoResult result) override;
-  void importKey(blink::WebCryptoKeyFormat format,
-                 const unsigned char* key_data,
-                 unsigned int key_data_size,
-                 const blink::WebCryptoAlgorithm& algorithm,
-                 bool extractable,
-                 blink::WebCryptoKeyUsageMask usages,
-                 blink::WebCryptoResult result) override;
-  void exportKey(blink::WebCryptoKeyFormat format,
-                 const blink::WebCryptoKey& key,
-                 blink::WebCryptoResult result) override;
-  void sign(const blink::WebCryptoAlgorithm& algorithm,
-            const blink::WebCryptoKey& key,
-            const unsigned char* data,
-            unsigned int data_size,
-            blink::WebCryptoResult result) override;
-  void verifySignature(const blink::WebCryptoAlgorithm& algorithm,
+  virtual ~WebCryptoImpl();
+
+  virtual void encrypt(const blink::WebCryptoAlgorithm& algorithm,
                        const blink::WebCryptoKey& key,
-                       const unsigned char* signature,
-                       unsigned int signature_size,
                        const unsigned char* data,
                        unsigned int data_size,
-                       blink::WebCryptoResult result) override;
-  void wrapKey(blink::WebCryptoKeyFormat format,
-               const blink::WebCryptoKey& key,
-               const blink::WebCryptoKey& wrapping_key,
-               const blink::WebCryptoAlgorithm& wrap_algorithm,
-               blink::WebCryptoResult result) override;
-  void unwrapKey(blink::WebCryptoKeyFormat format,
-                 const unsigned char* wrapped_key,
-                 unsigned wrapped_key_size,
-                 const blink::WebCryptoKey& wrapping_key,
-                 const blink::WebCryptoAlgorithm& unwrap_algorithm,
-                 const blink::WebCryptoAlgorithm& unwrapped_key_algorithm,
-                 bool extractable,
-                 blink::WebCryptoKeyUsageMask usages,
-                 blink::WebCryptoResult result) override;
-
-  void deriveBits(const blink::WebCryptoAlgorithm& algorithm,
-                  const blink::WebCryptoKey& base_key,
-                  unsigned int length_bits,
-                  blink::WebCryptoResult result) override;
-
-  void deriveKey(const blink::WebCryptoAlgorithm& algorithm,
-                 const blink::WebCryptoKey& base_key,
-                 const blink::WebCryptoAlgorithm& import_algorithm,
-                 const blink::WebCryptoAlgorithm& key_length_algorithm,
-                 bool extractable,
-                 blink::WebCryptoKeyUsageMask usages,
-                 blink::WebCryptoResult result) override;
+                       blink::WebCryptoResult result);
+  virtual void decrypt(const blink::WebCryptoAlgorithm& algorithm,
+                       const blink::WebCryptoKey& key,
+                       const unsigned char* data,
+                       unsigned int data_size,
+                       blink::WebCryptoResult result);
+  virtual void digest(const blink::WebCryptoAlgorithm& algorithm,
+                      const unsigned char* data,
+                      unsigned int data_size,
+                      blink::WebCryptoResult result);
+  virtual void generateKey(const blink::WebCryptoAlgorithm& algorithm,
+                           bool extractable,
+                           blink::WebCryptoKeyUsageMask usages,
+                           blink::WebCryptoResult result);
+  virtual void importKey(blink::WebCryptoKeyFormat format,
+                         const unsigned char* key_data,
+                         unsigned int key_data_size,
+                         const blink::WebCryptoAlgorithm& algorithm,
+                         bool extractable,
+                         blink::WebCryptoKeyUsageMask usages,
+                         blink::WebCryptoResult result);
+  virtual void exportKey(blink::WebCryptoKeyFormat format,
+                         const blink::WebCryptoKey& key,
+                         blink::WebCryptoResult result);
+  virtual void sign(const blink::WebCryptoAlgorithm& algorithm,
+                    const blink::WebCryptoKey& key,
+                    const unsigned char* data,
+                    unsigned int data_size,
+                    blink::WebCryptoResult result);
+  virtual void verifySignature(const blink::WebCryptoAlgorithm& algorithm,
+                               const blink::WebCryptoKey& key,
+                               const unsigned char* signature,
+                               unsigned int signature_size,
+                               const unsigned char* data,
+                               unsigned int data_size,
+                               blink::WebCryptoResult result);
+  virtual void wrapKey(blink::WebCryptoKeyFormat format,
+                       const blink::WebCryptoKey& key,
+                       const blink::WebCryptoKey& wrapping_key,
+                       const blink::WebCryptoAlgorithm& wrap_algorithm,
+                       blink::WebCryptoResult result);
+  virtual void unwrapKey(
+      blink::WebCryptoKeyFormat format,
+      const unsigned char* wrapped_key,
+      unsigned wrapped_key_size,
+      const blink::WebCryptoKey& wrapping_key,
+      const blink::WebCryptoAlgorithm& unwrap_algorithm,
+      const blink::WebCryptoAlgorithm& unwrapped_key_algorithm,
+      bool extractable,
+      blink::WebCryptoKeyUsageMask usages,
+      blink::WebCryptoResult result);
+
+  virtual void deriveBits(const blink::WebCryptoAlgorithm& algorithm,
+                          const blink::WebCryptoKey& base_key,
+                          unsigned int length_bits,
+                          blink::WebCryptoResult result);
+
+  virtual void deriveKey(const blink::WebCryptoAlgorithm& algorithm,
+                         const blink::WebCryptoKey& base_key,
+                         const blink::WebCryptoAlgorithm& import_algorithm,
+                         const blink::WebCryptoAlgorithm& key_length_algorithm,
+                         bool extractable,
+                         blink::WebCryptoKeyUsageMask usages,
+                         blink::WebCryptoResult result);
 
   // This method returns a digestor object that can be used to synchronously
   // compute a digest one chunk at a time. Thus, the consume does not need to
@@ -99,19 +103,20 @@
   // one at a time and the digest will be computed piecemeal. The allocated
   // WebCrytpoDigestor that is returned by createDigestor must be freed by the
   // caller.
-  blink::WebCryptoDigestor* createDigestor(
-      blink::WebCryptoAlgorithmId algorithm_id) override;
+  virtual blink::WebCryptoDigestor* createDigestor(
+      blink::WebCryptoAlgorithmId algorithm_id);
 
-  bool deserializeKeyForClone(const blink::WebCryptoKeyAlgorithm& algorithm,
-                              blink::WebCryptoKeyType type,
-                              bool extractable,
-                              blink::WebCryptoKeyUsageMask usages,
-                              const unsigned char* key_data,
-                              unsigned key_data_size,
-                              blink::WebCryptoKey& key) override;
+  virtual bool deserializeKeyForClone(
+      const blink::WebCryptoKeyAlgorithm& algorithm,
+      blink::WebCryptoKeyType type,
+      bool extractable,
+      blink::WebCryptoKeyUsageMask usages,
+      const unsigned char* key_data,
+      unsigned key_data_size,
+      blink::WebCryptoKey& key);
 
-  bool serializeKeyForClone(const blink::WebCryptoKey& key,
-                            blink::WebVector<unsigned char>& key_data) override;
+  virtual bool serializeKeyForClone(const blink::WebCryptoKey& key,
+                                    blink::WebVector<unsigned char>& key_data);
 
  private:
   DISALLOW_COPY_AND_ASSIGN(WebCryptoImpl);
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/webcrypto_util.cc	2016-02-25 15:58:25.272233732 +0000
@@ -0,0 +1,322 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/webcrypto_util.h"
+
+#include "base/logging.h"
+#include "base/numerics/safe_math.h"
+#include "components/webcrypto/status.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithm.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+// Converts a (big-endian) WebCrypto BigInteger, with or without leading zeros,
+// to unsigned int.
+bool BigIntegerToUint(const uint8_t* data,
+                      size_t data_size,
+                      unsigned int* result) {
+  if (data_size == 0)
+    return false;
+
+  *result = 0;
+  for (size_t i = 0; i < data_size; ++i) {
+    size_t reverse_i = data_size - i - 1;
+
+    if (reverse_i >= sizeof(*result) && data[i])
+      return false;  // Too large for a uint.
+
+    *result |= data[i] << 8 * reverse_i;
+  }
+  return true;
+}
+
+Status GetShaBlockSizeBits(const blink::WebCryptoAlgorithm& algorithm,
+                           unsigned int* block_size_bits) {
+  switch (algorithm.id()) {
+    case blink::WebCryptoAlgorithmIdSha1:
+    case blink::WebCryptoAlgorithmIdSha256:
+      *block_size_bits = 512;
+      return Status::Success();
+    case blink::WebCryptoAlgorithmIdSha384:
+    case blink::WebCryptoAlgorithmIdSha512:
+      *block_size_bits = 1024;
+      return Status::Success();
+    default:
+      return Status::ErrorUnsupported();
+  }
+}
+
+}  // namespace
+
+blink::WebCryptoAlgorithm CreateAlgorithm(blink::WebCryptoAlgorithmId id) {
+  return blink::WebCryptoAlgorithm::adoptParamsAndCreate(id, NULL);
+}
+
+blink::WebCryptoAlgorithm CreateHmacImportAlgorithm(
+    blink::WebCryptoAlgorithmId hash_id,
+    unsigned int length_bits) {
+  DCHECK(blink::WebCryptoAlgorithm::isHash(hash_id));
+  return blink::WebCryptoAlgorithm::adoptParamsAndCreate(
+      blink::WebCryptoAlgorithmIdHmac,
+      new blink::WebCryptoHmacImportParams(CreateAlgorithm(hash_id), true,
+                                           length_bits));
+}
+
+blink::WebCryptoAlgorithm CreateHmacImportAlgorithmNoLength(
+    blink::WebCryptoAlgorithmId hash_id) {
+  DCHECK(blink::WebCryptoAlgorithm::isHash(hash_id));
+  return blink::WebCryptoAlgorithm::adoptParamsAndCreate(
+      blink::WebCryptoAlgorithmIdHmac,
+      new blink::WebCryptoHmacImportParams(CreateAlgorithm(hash_id), false, 0));
+}
+
+blink::WebCryptoAlgorithm CreateRsaHashedImportAlgorithm(
+    blink::WebCryptoAlgorithmId id,
+    blink::WebCryptoAlgorithmId hash_id) {
+  DCHECK(blink::WebCryptoAlgorithm::isHash(hash_id));
+  return blink::WebCryptoAlgorithm::adoptParamsAndCreate(
+      id, new blink::WebCryptoRsaHashedImportParams(CreateAlgorithm(hash_id)));
+}
+
+blink::WebCryptoAlgorithm CreateEcImportAlgorithm(
+    blink::WebCryptoAlgorithmId id,
+    blink::WebCryptoNamedCurve named_curve) {
+  return blink::WebCryptoAlgorithm::adoptParamsAndCreate(
+      id, new blink::WebCryptoEcKeyImportParams(named_curve));
+}
+
+bool ContainsKeyUsages(blink::WebCryptoKeyUsageMask a,
+                       blink::WebCryptoKeyUsageMask b) {
+  return (a & b) == b;
+}
+
+// The WebCrypto spec defines the default value for the tag length, as well as
+// the allowed values for tag length.
+Status GetAesGcmTagLengthInBits(const blink::WebCryptoAesGcmParams* params,
+                                unsigned int* tag_length_bits) {
+  *tag_length_bits = 128;
+  if (params->hasTagLengthBits())
+    *tag_length_bits = params->optionalTagLengthBits();
+
+  if (*tag_length_bits != 32 && *tag_length_bits != 64 &&
+      *tag_length_bits != 96 && *tag_length_bits != 104 &&
+      *tag_length_bits != 112 && *tag_length_bits != 120 &&
+      *tag_length_bits != 128)
+    return Status::ErrorInvalidAesGcmTagLength();
+
+  return Status::Success();
+}
+
+Status GetAesKeyGenLengthInBits(const blink::WebCryptoAesKeyGenParams* params,
+                                unsigned int* keylen_bits) {
+  *keylen_bits = params->lengthBits();
+
+  if (*keylen_bits == 128 || *keylen_bits == 256)
+    return Status::Success();
+
+  // BoringSSL does not support 192-bit AES.
+  if (*keylen_bits == 192)
+    return Status::ErrorAes192BitUnsupported();
+
+  return Status::ErrorGenerateAesKeyLength();
+}
+
+Status GetHmacKeyGenLengthInBits(const blink::WebCryptoHmacKeyGenParams* params,
+                                 unsigned int* keylen_bits) {
+  if (!params->hasLengthBits())
+    return GetShaBlockSizeBits(params->hash(), keylen_bits);
+
+  *keylen_bits = params->optionalLengthBits();
+
+  // Zero-length HMAC keys are disallowed by the spec.
+  if (*keylen_bits == 0)
+    return Status::ErrorGenerateHmacKeyLengthZero();
+
+  return Status::Success();
+}
+
+Status GetHmacImportKeyLengthBits(
+    const blink::WebCryptoHmacImportParams* params,
+    unsigned int key_data_byte_length,
+    unsigned int* keylen_bits) {
+  if (key_data_byte_length == 0)
+    return Status::ErrorHmacImportEmptyKey();
+
+  // Make sure that the key data's length can be represented in bits without
+  // overflow.
+  base::CheckedNumeric<unsigned int> checked_keylen_bits(key_data_byte_length);
+  checked_keylen_bits *= 8;
+
+  if (!checked_keylen_bits.IsValid())
+    return Status::ErrorDataTooLarge();
+
+  unsigned int data_keylen_bits = checked_keylen_bits.ValueOrDie();
+
+  // Determine how many bits of the input to use.
+  *keylen_bits = data_keylen_bits;
+  if (params->hasLengthBits()) {
+    // The requested bit length must be:
+    //   * No longer than the input data length
+    //   * At most 7 bits shorter.
+    if (NumBitsToBytes(params->optionalLengthBits()) != key_data_byte_length)
+      return Status::ErrorHmacImportBadLength();
+    *keylen_bits = params->optionalLengthBits();
+  }
+
+  return Status::Success();
+}
+
+Status VerifyAesKeyLengthForImport(unsigned int keylen_bytes) {
+  if (keylen_bytes == 16 || keylen_bytes == 32)
+    return Status::Success();
+
+  // BoringSSL does not support 192-bit AES.
+  if (keylen_bytes == 24)
+    return Status::ErrorAes192BitUnsupported();
+
+  return Status::ErrorImportAesKeyLength();
+}
+
+Status CheckKeyCreationUsages(blink::WebCryptoKeyUsageMask all_possible_usages,
+                              blink::WebCryptoKeyUsageMask actual_usages,
+                              bool allow_empty_usages) {
+  if (!allow_empty_usages && actual_usages == 0)
+    return Status::ErrorCreateKeyEmptyUsages();
+
+  if (!ContainsKeyUsages(all_possible_usages, actual_usages))
+    return Status::ErrorCreateKeyBadUsages();
+  return Status::Success();
+}
+
+Status GetRsaKeyGenParameters(
+    const blink::WebCryptoRsaHashedKeyGenParams* params,
+    unsigned int* public_exponent,
+    unsigned int* modulus_length_bits) {
+  *modulus_length_bits = params->modulusLengthBits();
+
+  // Limit key sizes to those supported by NSS:
+  //   * Multiple of 8 bits
+  //   * 256 bits to 16K bits
+  if (*modulus_length_bits < 256 || *modulus_length_bits > 16384 ||
+      (*modulus_length_bits % 8) != 0) {
+    return Status::ErrorGenerateRsaUnsupportedModulus();
+  }
+
+  if (!BigIntegerToUint(params->publicExponent().data(),
+                        params->publicExponent().size(), public_exponent)) {
+    return Status::ErrorGenerateKeyPublicExponent();
+  }
+
+  // OpenSSL hangs when given bad public exponents, whereas NSS simply fails. To
+  // avoid feeding OpenSSL data that will hang use a whitelist.
+  if (*public_exponent != 3 && *public_exponent != 65537)
+    return Status::ErrorGenerateKeyPublicExponent();
+
+  return Status::Success();
+}
+
+Status VerifyUsagesBeforeImportAsymmetricKey(
+    blink::WebCryptoKeyFormat format,
+    blink::WebCryptoKeyUsageMask all_public_key_usages,
+    blink::WebCryptoKeyUsageMask all_private_key_usages,
+    blink::WebCryptoKeyUsageMask usages) {
+  switch (format) {
+    case blink::WebCryptoKeyFormatSpki:
+      return CheckKeyCreationUsages(all_public_key_usages, usages, true);
+    case blink::WebCryptoKeyFormatPkcs8:
+      return CheckKeyCreationUsages(all_private_key_usages, usages, false);
+    case blink::WebCryptoKeyFormatJwk: {
+      // The JWK could represent either a public key or private key. The usages
+      // must make sense for one of the two. The usages will be checked again by
+      // ImportKeyJwk() once the key type has been determined.
+      if (CheckKeyCreationUsages(all_public_key_usages, usages, true)
+              .IsError() &&
+          CheckKeyCreationUsages(all_private_key_usages, usages, false)
+              .IsError()) {
+        return Status::ErrorCreateKeyBadUsages();
+      }
+      return Status::Success();
+    }
+    default:
+      return Status::ErrorUnsupportedImportKeyFormat();
+  }
+}
+
+void TruncateToBitLength(size_t length_bits, std::vector<uint8_t>* bytes) {
+  size_t length_bytes = NumBitsToBytes(length_bits);
+
+  if (bytes->size() != length_bytes) {
+    CHECK_LT(length_bytes, bytes->size());
+    bytes->resize(length_bytes);
+  }
+
+  size_t remainder_bits = length_bits % 8;
+
+  // Zero any "unused bits" in the final byte
+  if (remainder_bits)
+    (*bytes)[bytes->size() - 1] &= ~((0xFF) >> remainder_bits);
+}
+
+Status GetAesKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                       bool* has_length_bits,
+                       unsigned int* length_bits) {
+  const blink::WebCryptoAesDerivedKeyParams* params =
+      key_length_algorithm.aesDerivedKeyParams();
+
+  *has_length_bits = true;
+  *length_bits = params->lengthBits();
+
+  if (*length_bits == 128 || *length_bits == 256)
+    return Status::Success();
+
+  // BoringSSL does not support 192-bit AES.
+  if (*length_bits == 192)
+    return Status::ErrorAes192BitUnsupported();
+
+  return Status::ErrorGetAesKeyLength();
+}
+
+Status GetHmacKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                        bool* has_length_bits,
+                        unsigned int* length_bits) {
+  const blink::WebCryptoHmacImportParams* params =
+      key_length_algorithm.hmacImportParams();
+
+  if (params->hasLengthBits()) {
+    *has_length_bits = true;
+    *length_bits = params->optionalLengthBits();
+    if (*length_bits == 0)
+      return Status::ErrorGetHmacKeyLengthZero();
+    return Status::Success();
+  }
+
+  *has_length_bits = true;
+  return GetShaBlockSizeBits(params->hash(), length_bits);
+}
+
+Status GetUsagesForGenerateAsymmetricKey(
+    blink::WebCryptoKeyUsageMask combined_usages,
+    blink::WebCryptoKeyUsageMask all_public_usages,
+    blink::WebCryptoKeyUsageMask all_private_usages,
+    blink::WebCryptoKeyUsageMask* public_usages,
+    blink::WebCryptoKeyUsageMask* private_usages) {
+  Status status = CheckKeyCreationUsages(all_public_usages | all_private_usages,
+                                         combined_usages, true);
+  if (status.IsError())
+    return status;
+
+  *public_usages = combined_usages & all_public_usages;
+  *private_usages = combined_usages & all_private_usages;
+
+  if (*private_usages == 0)
+    return Status::ErrorCreateKeyEmptyUsages();
+
+  return Status::Success();
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/webcrypto_util.h	2016-02-25 15:58:50.920605034 +0000
@@ -0,0 +1,130 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_WEBCRYPTO_UTIL_H_
+#define COMPONENTS_WEBCRYPTO_WEBCRYPTO_UTIL_H_
+
+#include <stdint.h>
+#include <string>
+
+#include "base/values.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithm.h"
+#include "third_party/WebKit/public/platform/WebCryptoKey.h"
+
+namespace webcrypto {
+
+class Status;
+
+// Creates a WebCryptoAlgorithm without any parameters.
+blink::WebCryptoAlgorithm CreateAlgorithm(blink::WebCryptoAlgorithmId id);
+
+// Creates an HMAC import algorithm whose inner hash algorithm is determined by
+// the specified algorithm ID. It is an error to call this method with a hash
+// algorithm that is not SHA*.
+blink::WebCryptoAlgorithm CreateHmacImportAlgorithm(
+    blink::WebCryptoAlgorithmId hash_id,
+    unsigned int length_bits);
+
+// Same as above but without specifying a length.
+blink::WebCryptoAlgorithm CreateHmacImportAlgorithmNoLength(
+    blink::WebCryptoAlgorithmId hash_id);
+
+// Creates an import algorithm for RSA algorithms that take a hash.
+// It is an error to call this with a hash_id that is not a SHA*.
+blink::WebCryptoAlgorithm CreateRsaHashedImportAlgorithm(
+    blink::WebCryptoAlgorithmId id,
+    blink::WebCryptoAlgorithmId hash_id);
+
+// Creates an import algorithm for EC keys.
+blink::WebCryptoAlgorithm CreateEcImportAlgorithm(
+    blink::WebCryptoAlgorithmId id,
+    blink::WebCryptoNamedCurve named_curve);
+
+// Returns true if the set bits in b make up a subset of the set bits in a.
+bool ContainsKeyUsages(blink::WebCryptoKeyUsageMask a,
+                       blink::WebCryptoKeyUsageMask b);
+
+Status GetAesGcmTagLengthInBits(const blink::WebCryptoAesGcmParams* params,
+                                unsigned int* tag_length_bits);
+
+Status GetAesKeyGenLengthInBits(const blink::WebCryptoAesKeyGenParams* params,
+                                unsigned int* keylen_bits);
+
+Status GetHmacKeyGenLengthInBits(const blink::WebCryptoHmacKeyGenParams* params,
+                                 unsigned int* keylen_bits);
+
+// Gets the requested key length in bits for an HMAC import operation.
+Status GetHmacImportKeyLengthBits(
+    const blink::WebCryptoHmacImportParams* params,
+    unsigned int key_data_byte_length,
+    unsigned int* keylen_bits);
+
+Status VerifyAesKeyLengthForImport(unsigned int keylen_bytes);
+
+Status CheckKeyCreationUsages(blink::WebCryptoKeyUsageMask all_possible_usages,
+                              blink::WebCryptoKeyUsageMask actual_usages,
+                              bool allow_empty_usages);
+
+// Extracts the public exponent and modulus length from the Blink parameters.
+// On success it is guaranteed that:
+//   * public_exponent is either 3 or 65537
+//   * modulus_length_bits is a multiple of 8
+//   * modulus_length is >= 256
+//   * modulus_length is <= 16K
+Status GetRsaKeyGenParameters(
+    const blink::WebCryptoRsaHashedKeyGenParams* params,
+    unsigned int* public_exponent,
+    unsigned int* modulus_length_bits);
+
+// Verifies that |usages| is valid when importing a key of the given format.
+Status VerifyUsagesBeforeImportAsymmetricKey(
+    blink::WebCryptoKeyFormat format,
+    blink::WebCryptoKeyUsageMask all_public_key_usages,
+    blink::WebCryptoKeyUsageMask all_private_key_usages,
+    blink::WebCryptoKeyUsageMask usages);
+
+// Truncates an octet string to a particular bit length. This is accomplished by
+// resizing to the closest byte length, and then zero-ing the unused
+// least-significant bits of the final byte.
+//
+// It is an error to call this function with a bit length that is larger than
+// that of |bytes|.
+//
+// TODO(eroman): This operation is not yet defined by the WebCrypto spec,
+// however this is a reasonable interpretation:
+// https://www.w3.org/Bugs/Public/show_bug.cgi?id=27402
+void TruncateToBitLength(size_t length_bits, std::vector<uint8_t>* bytes);
+
+// Rounds a bit count (up) to the nearest byte count.
+//
+// This is mathematically equivalent to (x + 7) / 8, however has no
+// possibility of integer overflow.
+template <typename T>
+T NumBitsToBytes(T x) {
+  return (x / 8) + (7 + (x % 8)) / 8;
+}
+
+// The "get key length" operation for AES keys.
+Status GetAesKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                       bool* has_length_bits,
+                       unsigned int* length_bits);
+
+// The "get key length" operation for HMAC keys.
+Status GetHmacKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                        bool* has_length_bits,
+                        unsigned int* length_bits);
+
+// Splits the combined usages given to GenerateKey() into the respective usages
+// for the public key and private key. Returns an error if the usages are
+// invalid.
+Status GetUsagesForGenerateAsymmetricKey(
+    blink::WebCryptoKeyUsageMask combined_usages,
+    blink::WebCryptoKeyUsageMask all_public_usages,
+    blink::WebCryptoKeyUsageMask all_private_usages,
+    blink::WebCryptoKeyUsageMask* public_usages,
+    blink::WebCryptoKeyUsageMask* private_usages);
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_WEBCRYPTO_UTIL_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/platform_crypto.h	2016-02-25 15:59:52.272495010 +0000
@@ -0,0 +1,40 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_PLATFORM_CRYPTO_H_
+#define COMPONENTS_WEBCRYPTO_PLATFORM_CRYPTO_H_
+
+#include <stdint.h>
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "third_party/WebKit/public/platform/WebCrypto.h"
+
+// The definitions for these methods lives in either nss/ or openssl/
+namespace webcrypto {
+
+class AlgorithmImplementation;
+
+void PlatformInit();
+
+scoped_ptr<blink::WebCryptoDigestor> CreatePlatformDigestor(
+    blink::WebCryptoAlgorithmId algorithm);
+
+AlgorithmImplementation* CreatePlatformShaImplementation();
+AlgorithmImplementation* CreatePlatformAesCbcImplementation();
+AlgorithmImplementation* CreatePlatformAesCtrImplementation();
+AlgorithmImplementation* CreatePlatformAesGcmImplementation();
+AlgorithmImplementation* CreatePlatformAesKwImplementation();
+AlgorithmImplementation* CreatePlatformHmacImplementation();
+AlgorithmImplementation* CreatePlatformRsaOaepImplementation();
+AlgorithmImplementation* CreatePlatformRsaSsaImplementation();
+AlgorithmImplementation* CreatePlatformRsaPssImplementation();
+AlgorithmImplementation* CreatePlatformEcdsaImplementation();
+AlgorithmImplementation* CreatePlatformEcdhImplementation();
+AlgorithmImplementation* CreatePlatformHkdfImplementation();
+AlgorithmImplementation* CreatePlatformPbkdf2Implementation();
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_PLATFORM_CRYPTO_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/aes_algorithm_nss.cc	2016-02-25 13:41:16.163373129 +0000
@@ -0,0 +1,141 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/nss/aes_algorithm_nss.h"
+
+#include "base/logging.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/jwk.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/sym_key_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+AesAlgorithm::AesAlgorithm(CK_MECHANISM_TYPE import_mechanism,
+                           blink::WebCryptoKeyUsageMask all_key_usages,
+                           const std::string& jwk_suffix)
+    : import_mechanism_(import_mechanism),
+      all_key_usages_(all_key_usages),
+      jwk_suffix_(jwk_suffix) {
+}
+
+AesAlgorithm::AesAlgorithm(CK_MECHANISM_TYPE import_mechanism,
+                           const std::string& jwk_suffix)
+    : import_mechanism_(import_mechanism),
+      all_key_usages_(blink::WebCryptoKeyUsageEncrypt |
+                      blink::WebCryptoKeyUsageDecrypt |
+                      blink::WebCryptoKeyUsageWrapKey |
+                      blink::WebCryptoKeyUsageUnwrapKey),
+      jwk_suffix_(jwk_suffix) {
+}
+
+Status AesAlgorithm::GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                                 bool extractable,
+                                 blink::WebCryptoKeyUsageMask usages,
+                                 GenerateKeyResult* result) const {
+  Status status = CheckKeyCreationUsages(all_key_usages_, usages, false);
+  if (status.IsError())
+    return status;
+
+  unsigned int keylen_bits;
+  status = GetAesKeyGenLengthInBits(algorithm.aesKeyGenParams(), &keylen_bits);
+  if (status.IsError())
+    return status;
+
+  return GenerateSecretKeyNss(
+      blink::WebCryptoKeyAlgorithm::createAes(algorithm.id(), keylen_bits),
+      extractable, usages, keylen_bits, CKM_AES_KEY_GEN, result);
+}
+
+Status AesAlgorithm::VerifyKeyUsagesBeforeImportKey(
+    blink::WebCryptoKeyFormat format,
+    blink::WebCryptoKeyUsageMask usages) const {
+  switch (format) {
+    case blink::WebCryptoKeyFormatRaw:
+    case blink::WebCryptoKeyFormatJwk:
+      return CheckKeyCreationUsages(all_key_usages_, usages, false);
+    default:
+      return Status::ErrorUnsupportedImportKeyFormat();
+  }
+}
+Status AesAlgorithm::ImportKeyRaw(const CryptoData& key_data,
+                                  const blink::WebCryptoAlgorithm& algorithm,
+                                  bool extractable,
+                                  blink::WebCryptoKeyUsageMask usages,
+                                  blink::WebCryptoKey* key) const {
+  const unsigned int keylen_bytes = key_data.byte_length();
+  Status status = VerifyAesKeyLengthForImport(keylen_bytes);
+  if (status.IsError())
+    return status;
+
+  // No possibility of overflow.
+  unsigned int keylen_bits = keylen_bytes * 8;
+
+  return ImportKeyRawNss(key_data, blink::WebCryptoKeyAlgorithm::createAes(
+                                       algorithm.id(), keylen_bits),
+                         extractable, usages, import_mechanism_, key);
+}
+
+Status AesAlgorithm::ImportKeyJwk(const CryptoData& key_data,
+                                  const blink::WebCryptoAlgorithm& algorithm,
+                                  bool extractable,
+                                  blink::WebCryptoKeyUsageMask usages,
+                                  blink::WebCryptoKey* key) const {
+  std::vector<uint8_t> raw_data;
+  Status status = ReadAesSecretKeyJwk(key_data, jwk_suffix_, extractable,
+                                      usages, &raw_data);
+  if (status.IsError())
+    return status;
+
+  return ImportKeyRaw(CryptoData(raw_data), algorithm, extractable, usages,
+                      key);
+}
+
+Status AesAlgorithm::ExportKeyRaw(const blink::WebCryptoKey& key,
+                                  std::vector<uint8_t>* buffer) const {
+  *buffer = SymKeyNss::Cast(key)->raw_key_data();
+  return Status::Success();
+}
+
+Status AesAlgorithm::ExportKeyJwk(const blink::WebCryptoKey& key,
+                                  std::vector<uint8_t>* buffer) const {
+  SymKeyNss* sym_key = SymKeyNss::Cast(key);
+  const std::vector<uint8_t>& raw_data = sym_key->raw_key_data();
+
+  WriteSecretKeyJwk(CryptoData(raw_data),
+                    MakeJwkAesAlgorithmName(jwk_suffix_, raw_data.size()),
+                    key.extractable(), key.usages(), buffer);
+
+  return Status::Success();
+}
+
+Status AesAlgorithm::SerializeKeyForClone(
+    const blink::WebCryptoKey& key,
+    blink::WebVector<uint8_t>* key_data) const {
+  key_data->assign(SymKeyNss::Cast(key)->serialized_key_data());
+  return Status::Success();
+}
+
+Status AesAlgorithm::DeserializeKeyForClone(
+    const blink::WebCryptoKeyAlgorithm& algorithm,
+    blink::WebCryptoKeyType type,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask usages,
+    const CryptoData& key_data,
+    blink::WebCryptoKey* key) const {
+  return ImportKeyRaw(key_data, CreateAlgorithm(algorithm.id()), extractable,
+                      usages, key);
+}
+
+Status AesAlgorithm::GetKeyLength(
+    const blink::WebCryptoAlgorithm& key_length_algorithm,
+    bool* has_length_bits,
+    unsigned int* length_bits) const {
+  return GetAesKeyLength(key_length_algorithm, has_length_bits, length_bits);
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/aes_algorithm_nss.h	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,85 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_NSS_AES_ALGORITHM_NSS_H_
+#define COMPONENTS_WEBCRYPTO_NSS_AES_ALGORITHM_NSS_H_
+
+#include <pkcs11t.h>
+
+#include "components/webcrypto/algorithm_implementation.h"
+
+namespace webcrypto {
+
+// Base class for AES algorithms that provides the implementation for key
+// creation and export.
+class AesAlgorithm : public AlgorithmImplementation {
+ public:
+  // Constructs an AES algorithm whose keys will be imported using the NSS
+  // mechanism |import_mechanism|.
+  // |all_key_usages| is the set of all WebCrypto key usages that are
+  // allowed for imported or generated keys. |jwk_suffix| is the suffix
+  // used when constructing JWK names for the algorithm. For instance A128CBC
+  // is the JWK name for 128-bit AES-CBC. The |jwk_suffix| in this case would
+  // be "CBC".
+  AesAlgorithm(CK_MECHANISM_TYPE import_mechanism,
+               blink::WebCryptoKeyUsageMask all_key_usages,
+               const std::string& jwk_suffix);
+
+  // This is the same as the other AesAlgorithm constructor, however
+  // |all_key_usages| is pre-filled with values for encryption/decryption
+  // algorithms (supports usages for: encrypt, decrypt, wrap, unwrap).
+  AesAlgorithm(CK_MECHANISM_TYPE import_mechanism,
+               const std::string& jwk_suffix);
+
+  Status GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                     bool extractable,
+                     blink::WebCryptoKeyUsageMask usages,
+                     GenerateKeyResult* result) const override;
+
+  Status VerifyKeyUsagesBeforeImportKey(
+      blink::WebCryptoKeyFormat format,
+      blink::WebCryptoKeyUsageMask usages) const override;
+
+  Status ImportKeyRaw(const CryptoData& key_data,
+                      const blink::WebCryptoAlgorithm& algorithm,
+                      bool extractable,
+                      blink::WebCryptoKeyUsageMask usages,
+                      blink::WebCryptoKey* key) const override;
+
+  Status ImportKeyJwk(const CryptoData& key_data,
+                      const blink::WebCryptoAlgorithm& algorithm,
+                      bool extractable,
+                      blink::WebCryptoKeyUsageMask usages,
+                      blink::WebCryptoKey* key) const override;
+
+  Status ExportKeyRaw(const blink::WebCryptoKey& key,
+                      std::vector<uint8_t>* buffer) const override;
+
+  Status ExportKeyJwk(const blink::WebCryptoKey& key,
+                      std::vector<uint8_t>* buffer) const override;
+
+  Status SerializeKeyForClone(
+      const blink::WebCryptoKey& key,
+      blink::WebVector<uint8_t>* key_data) const override;
+
+  Status DeserializeKeyForClone(const blink::WebCryptoKeyAlgorithm& algorithm,
+                                blink::WebCryptoKeyType type,
+                                bool extractable,
+                                blink::WebCryptoKeyUsageMask usages,
+                                const CryptoData& key_data,
+                                blink::WebCryptoKey* key) const override;
+
+  Status GetKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                      bool* has_length_bits,
+                      unsigned int* length_bits) const override;
+
+ private:
+  const CK_MECHANISM_TYPE import_mechanism_;
+  const blink::WebCryptoKeyUsageMask all_key_usages_;
+  const std::string jwk_suffix_;
+};
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_NSS_AES_ALGORITHM_NSS_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/aes_cbc_nss.cc	2016-02-25 14:36:55.259587993 +0000
@@ -0,0 +1,120 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cryptohi.h>
+
+#include "base/numerics/safe_math.h"
+#include "base/stl_util.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/aes_algorithm_nss.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+
+namespace webcrypto {
+
+namespace {
+
+Status AesCbcEncryptDecrypt(EncryptOrDecrypt mode,
+                            const blink::WebCryptoAlgorithm& algorithm,
+                            const blink::WebCryptoKey& key,
+                            const CryptoData& data,
+                            std::vector<uint8_t>* buffer) {
+  const blink::WebCryptoAesCbcParams* params = algorithm.aesCbcParams();
+  if (!params)
+    return Status::ErrorUnexpected();
+
+  CryptoData iv(params->iv().data(), params->iv().size());
+  if (iv.byte_length() != 16)
+    return Status::ErrorIncorrectSizeAesCbcIv();
+
+  PK11SymKey* sym_key = SymKeyNss::Cast(key)->key();
+
+  CK_ATTRIBUTE_TYPE operation = (mode == ENCRYPT) ? CKA_ENCRYPT : CKA_DECRYPT;
+
+  SECItem iv_item = MakeSECItemForBuffer(iv);
+
+  crypto::ScopedSECItem param(PK11_ParamFromIV(CKM_AES_CBC_PAD, &iv_item));
+  if (!param)
+    return Status::OperationError();
+
+  crypto::ScopedPK11Context context(PK11_CreateContextBySymKey(
+      CKM_AES_CBC_PAD, operation, sym_key, param.get()));
+
+  if (!context.get())
+    return Status::OperationError();
+
+  // Oddly PK11_CipherOp takes input and output lengths as "int" rather than
+  // "unsigned int". Do some checks now to avoid integer overflowing.
+  base::CheckedNumeric<int> output_max_len = data.byte_length();
+  output_max_len += AES_BLOCK_SIZE;
+  if (!output_max_len.IsValid()) {
+    // TODO(eroman): Handle this by chunking the input fed into NSS. Right now
+    // it doesn't make much difference since the one-shot API would end up
+    // blowing out the memory and crashing anyway.
+    return Status::ErrorDataTooLarge();
+  }
+
+  // PK11_CipherOp does an invalid memory access when given empty decryption
+  // input, or input which is not a multiple of the block size. See also
+  // https://bugzilla.mozilla.com/show_bug.cgi?id=921687.
+  if (operation == CKA_DECRYPT &&
+      (data.byte_length() == 0 || (data.byte_length() % AES_BLOCK_SIZE != 0))) {
+    return Status::OperationError();
+  }
+
+  // TODO(eroman): Refine the output buffer size. It can be computed exactly for
+  //               encryption, and can be smaller for decryption.
+  buffer->resize(output_max_len.ValueOrDie());
+
+  unsigned char* buffer_data = buffer->data();
+
+  int output_len;
+  if (SECSuccess != PK11_CipherOp(context.get(), buffer_data, &output_len,
+                                  buffer->size(), data.bytes(),
+                                  data.byte_length())) {
+    return Status::OperationError();
+  }
+
+  unsigned int final_output_chunk_len;
+  if (SECSuccess !=
+      PK11_DigestFinal(context.get(), buffer_data + output_len,
+                       &final_output_chunk_len,
+                       (output_max_len - output_len).ValueOrDie())) {
+    return Status::OperationError();
+  }
+
+  buffer->resize(final_output_chunk_len + output_len);
+  return Status::Success();
+}
+
+class AesCbcImplementation : public AesAlgorithm {
+ public:
+  AesCbcImplementation() : AesAlgorithm(CKM_AES_CBC, "CBC") {}
+
+  Status Encrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    return AesCbcEncryptDecrypt(ENCRYPT, algorithm, key, data, buffer);
+  }
+
+  Status Decrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    return AesCbcEncryptDecrypt(DECRYPT, algorithm, key, data, buffer);
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformAesCbcImplementation() {
+  return new AesCbcImplementation;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/aes_gcm_nss.cc	2016-02-25 14:37:14.547866494 +0000
@@ -0,0 +1,182 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/numerics/safe_math.h"
+#include "base/stl_util.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/aes_algorithm_nss.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+
+// At the time of this writing:
+//   * Windows and Mac builds ship with their own copy of NSS (3.15+)
+//   * Linux builds use the system's libnss, which is 3.14 on Debian (but 3.15+
+//     on other distros).
+//
+// Since NSS provides AES-GCM support starting in version 3.15, it may be
+// unavailable for Linux Chrome users.
+//
+//  * !defined(CKM_AES_GCM)
+//
+//      This means that at build time, the NSS header pkcs11t.h is older than
+//      3.15. However at runtime support may be present.
+//
+// TODO(eroman): Simplify this once 3.15+ is required by Linux builds.
+#if !defined(CKM_AES_GCM)
+#define CKM_AES_GCM 0x00001087
+
+struct CK_GCM_PARAMS {
+  CK_BYTE_PTR pIv;
+  CK_ULONG ulIvLen;
+  CK_BYTE_PTR pAAD;
+  CK_ULONG ulAADLen;
+  CK_ULONG ulTagBits;
+};
+#endif  // !defined(CKM_AES_GCM)
+
+namespace webcrypto {
+
+namespace {
+
+Status NssSupportsAesGcm() {
+  if (NssRuntimeSupport::Get()->IsAesGcmSupported())
+    return Status::Success();
+  return Status::ErrorUnsupported(
+      "NSS version doesn't support AES-GCM. Try using version 3.15 or later");
+}
+
+// Helper to either encrypt or decrypt for AES-GCM. The result of encryption is
+// the concatenation of the ciphertext and the authentication tag. Similarly,
+// this is the expectation for the input to decryption.
+Status AesGcmEncryptDecrypt(EncryptOrDecrypt mode,
+                            const blink::WebCryptoAlgorithm& algorithm,
+                            const blink::WebCryptoKey& key,
+                            const CryptoData& data,
+                            std::vector<uint8_t>* buffer) {
+  Status status = NssSupportsAesGcm();
+  if (status.IsError())
+    return status;
+
+  PK11SymKey* sym_key = SymKeyNss::Cast(key)->key();
+  const blink::WebCryptoAesGcmParams* params = algorithm.aesGcmParams();
+  if (!params)
+    return Status::ErrorUnexpected();
+
+  unsigned int tag_length_bits;
+  status = GetAesGcmTagLengthInBits(params, &tag_length_bits);
+  if (status.IsError())
+    return status;
+  unsigned int tag_length_bytes = tag_length_bits / 8;
+
+  CryptoData iv(params->iv());
+  CryptoData additional_data(params->optionalAdditionalData());
+
+  CK_GCM_PARAMS gcm_params = {0};
+  gcm_params.pIv = const_cast<unsigned char*>(iv.bytes());
+  gcm_params.ulIvLen = iv.byte_length();
+
+  gcm_params.pAAD = const_cast<unsigned char*>(additional_data.bytes());
+  gcm_params.ulAADLen = additional_data.byte_length();
+
+  gcm_params.ulTagBits = tag_length_bits;
+
+  SECItem param;
+  param.type = siBuffer;
+  param.data = reinterpret_cast<unsigned char*>(&gcm_params);
+  param.len = sizeof(gcm_params);
+
+  base::CheckedNumeric<unsigned int> buffer_size(data.byte_length());
+
+  // Calculate the output buffer size.
+  if (mode == ENCRYPT) {
+    buffer_size += tag_length_bytes;
+    if (!buffer_size.IsValid())
+      return Status::ErrorDataTooLarge();
+  }
+
+  // TODO(eroman): In theory the buffer allocated for the plain text should be
+  // sized as |data.byte_length() - tag_length_bytes|.
+  //
+  // However NSS has a bug whereby it will fail if the output buffer size is
+  // not at least as large as the ciphertext:
+  //
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=%20853674
+  //
+  // From the analysis of that bug it looks like it might be safe to pass a
+  // correctly sized buffer but lie about its size. Since resizing the
+  // WebCryptoArrayBuffer is expensive that hack may be worth looking into.
+
+  buffer->resize(buffer_size.ValueOrDie());
+  unsigned char* buffer_data = buffer->data();
+
+  PK11_EncryptDecryptFunction encrypt_or_decrypt_func =
+      (mode == ENCRYPT) ? NssRuntimeSupport::Get()->pk11_encrypt_func()
+                        : NssRuntimeSupport::Get()->pk11_decrypt_func();
+
+  unsigned int output_len = 0;
+  SECStatus result = encrypt_or_decrypt_func(
+      sym_key, CKM_AES_GCM, &param, buffer_data, &output_len, buffer->size(),
+      data.bytes(), data.byte_length());
+
+  if (result != SECSuccess)
+    return Status::OperationError();
+
+  // Unfortunately the buffer needs to be shrunk for decryption (see the NSS bug
+  // above).
+  buffer->resize(output_len);
+
+  return Status::Success();
+}
+
+class AesGcmImplementation : public AesAlgorithm {
+ public:
+  AesGcmImplementation() : AesAlgorithm(CKM_AES_GCM, "GCM") {}
+
+  Status VerifyKeyUsagesBeforeImportKey(
+      blink::WebCryptoKeyFormat format,
+      blink::WebCryptoKeyUsageMask usages) const override {
+    // Prevent importing AES-GCM keys if it is unavailable.
+    Status status = NssSupportsAesGcm();
+    if (status.IsError())
+      return status;
+    return AesAlgorithm::VerifyKeyUsagesBeforeImportKey(format, usages);
+  }
+
+  Status GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                     bool extractable,
+                     blink::WebCryptoKeyUsageMask usages,
+                     GenerateKeyResult* result) const override {
+    // Prevent generating AES-GCM keys if it is unavailable.
+    Status status = NssSupportsAesGcm();
+    if (status.IsError())
+      return status;
+
+    return AesAlgorithm::GenerateKey(algorithm, extractable, usages, result);
+  }
+
+  Status Encrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    return AesGcmEncryptDecrypt(ENCRYPT, algorithm, key, data, buffer);
+  }
+
+  Status Decrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    return AesGcmEncryptDecrypt(DECRYPT, algorithm, key, data, buffer);
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformAesGcmImplementation() {
+  return new AesGcmImplementation;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/aes_kw_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,186 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <secerr.h>
+
+#include "base/numerics/safe_math.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/aes_algorithm_nss.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/sym_key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+// The Default IV for AES-KW. See http://www.ietf.org/rfc/rfc3394.txt
+// Section 2.2.3.1.
+const unsigned char kAesIv[] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};
+
+// The result of unwrapping is a SymKey rather than a buffer. This is a
+// consequence of how NSS exposes AES-KW. Subsequent code can extract the value
+// of the sym key to interpret it as key bytes in another format.
+Status DoUnwrapSymKeyAesKw(const CryptoData& wrapped_key_data,
+                           PK11SymKey* wrapping_key,
+                           CK_MECHANISM_TYPE mechanism,
+                           CK_FLAGS flags,
+                           crypto::ScopedPK11SymKey* unwrapped_key) {
+  DCHECK_GE(wrapped_key_data.byte_length(), 24u);
+  DCHECK_EQ(wrapped_key_data.byte_length() % 8, 0u);
+
+  SECItem iv_item = MakeSECItemForBuffer(CryptoData(kAesIv, sizeof(kAesIv)));
+  crypto::ScopedSECItem param_item(
+      PK11_ParamFromIV(CKM_NSS_AES_KEY_WRAP, &iv_item));
+  if (!param_item)
+    return Status::ErrorUnexpected();
+
+  SECItem cipher_text = MakeSECItemForBuffer(wrapped_key_data);
+
+  // The plaintext length is always 64 bits less than the data size.
+  const unsigned int plaintext_length = wrapped_key_data.byte_length() - 8;
+
+#if defined(USE_NSS_CERTS)
+  // Part of workaround for
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=981170. See the explanation
+  // later in this function.
+  PORT_SetError(0);
+#endif
+
+  crypto::ScopedPK11SymKey new_key(PK11_UnwrapSymKeyWithFlags(
+      wrapping_key, CKM_NSS_AES_KEY_WRAP, param_item.get(), &cipher_text,
+      mechanism, CKA_FLAGS_ONLY, plaintext_length, flags));
+
+  // TODO(padolph): Use NSS PORT_GetError() and friends to report a more
+  // accurate error, providing if doesn't leak any information to web pages
+  // about other web crypto users, key details, etc.
+  if (!new_key)
+    return Status::OperationError();
+
+#if defined(USE_NSS_CERTS)
+  // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=981170
+  // which was fixed in NSS 3.16.0.
+  // If unwrap fails, NSS nevertheless returns a valid-looking PK11SymKey,
+  // with a reasonable length but with key data pointing to uninitialized
+  // memory.
+  // To understand this workaround see the fix for 981170:
+  // https://hg.mozilla.org/projects/nss/rev/753bb69e543c
+  if (!NSS_VersionCheck("3.16") && PORT_GetError() == SEC_ERROR_BAD_DATA)
+    return Status::OperationError();
+#endif
+
+  *unwrapped_key = new_key.Pass();
+  return Status::Success();
+}
+
+Status WrapSymKeyAesKw(PK11SymKey* key,
+                       PK11SymKey* wrapping_key,
+                       std::vector<uint8_t>* buffer) {
+  // The data size must be at least 16 bytes and a multiple of 8 bytes.
+  // RFC 3394 does not specify a maximum allowed data length, but since only
+  // keys are being wrapped in this application (which are small), a reasonable
+  // max limit is whatever will fit into an unsigned. For the max size test,
+  // note that AES Key Wrap always adds 8 bytes to the input data size.
+  const unsigned int input_length = PK11_GetKeyLength(key);
+  DCHECK_GE(input_length, 16u);
+  DCHECK((input_length % 8) == 0);
+
+  SECItem iv_item = MakeSECItemForBuffer(CryptoData(kAesIv, sizeof(kAesIv)));
+  crypto::ScopedSECItem param_item(
+      PK11_ParamFromIV(CKM_NSS_AES_KEY_WRAP, &iv_item));
+  if (!param_item)
+    return Status::ErrorUnexpected();
+
+  base::CheckedNumeric<unsigned int> output_length = input_length;
+  output_length += 8;
+  if (!output_length.IsValid())
+    return Status::ErrorDataTooLarge();
+
+  buffer->resize(output_length.ValueOrDie());
+  SECItem wrapped_key_item = MakeSECItemForBuffer(CryptoData(*buffer));
+
+  if (SECSuccess != PK11_WrapSymKey(CKM_NSS_AES_KEY_WRAP, param_item.get(),
+                                    wrapping_key, key, &wrapped_key_item)) {
+    return Status::OperationError();
+  }
+  if (output_length.ValueOrDie() != wrapped_key_item.len)
+    return Status::ErrorUnexpected();
+
+  return Status::Success();
+}
+
+class AesKwCryptoAlgorithmNss : public AesAlgorithm {
+ public:
+  AesKwCryptoAlgorithmNss()
+      : AesAlgorithm(
+            CKM_NSS_AES_KEY_WRAP,
+            blink::WebCryptoKeyUsageWrapKey | blink::WebCryptoKeyUsageUnwrapKey,
+            "KW") {}
+
+  Status Encrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& wrapping_key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    if (data.byte_length() < 16)
+      return Status::ErrorDataTooSmall();
+    if (data.byte_length() % 8)
+      return Status::ErrorInvalidAesKwDataLength();
+
+    // Due to limitations in the NSS API for the AES-KW algorithm, |data| must
+    // be temporarily viewed as a symmetric key to be wrapped (encrypted).
+    SECItem data_item = MakeSECItemForBuffer(data);
+    crypto::ScopedPK11Slot slot(PK11_GetInternalSlot());
+    crypto::ScopedPK11SymKey data_as_sym_key(
+        PK11_ImportSymKey(slot.get(), CKK_GENERIC_SECRET, PK11_OriginUnwrap,
+                          CKA_SIGN, &data_item, NULL));
+    if (!data_as_sym_key)
+      return Status::OperationError();
+
+    return WrapSymKeyAesKw(data_as_sym_key.get(),
+                           SymKeyNss::Cast(wrapping_key)->key(), buffer);
+  }
+
+  Status Decrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& wrapping_key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    if (data.byte_length() < 24)
+      return Status::ErrorDataTooSmall();
+    if (data.byte_length() % 8)
+      return Status::ErrorInvalidAesKwDataLength();
+
+    // Due to limitations in the NSS API for the AES-KW algorithm, |data| must
+    // be temporarily viewed as a symmetric key to be unwrapped (decrypted).
+    crypto::ScopedPK11SymKey decrypted;
+    Status status =
+        DoUnwrapSymKeyAesKw(data, SymKeyNss::Cast(wrapping_key)->key(),
+                            CKK_GENERIC_SECRET, 0, &decrypted);
+    if (status.IsError())
+      return status;
+
+    // Once the decrypt is complete, extract the resultant raw bytes from NSS
+    // and return them to the caller.
+    if (PK11_ExtractKeyValue(decrypted.get()) != SECSuccess)
+      return Status::OperationError();
+    const SECItem* const key_data = PK11_GetKeyData(decrypted.get());
+    if (!key_data)
+      return Status::OperationError();
+    buffer->assign(key_data->data, key_data->data + key_data->len);
+
+    return Status::Success();
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformAesKwImplementation() {
+  return new AesKwCryptoAlgorithmNss;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/hmac_nss.cc	2016-02-25 14:38:13.675720223 +0000
@@ -0,0 +1,261 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cryptohi.h>
+#include <pk11pub.h>
+#include <secerr.h>
+#include <sechash.h>
+
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "components/webcrypto/algorithm_implementation.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/jwk.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/sym_key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/secure_util.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+const blink::WebCryptoKeyUsageMask kAllKeyUsages =
+    blink::WebCryptoKeyUsageSign | blink::WebCryptoKeyUsageVerify;
+
+bool WebCryptoHashToHMACMechanism(const blink::WebCryptoAlgorithm& algorithm,
+                                  CK_MECHANISM_TYPE* mechanism) {
+  switch (algorithm.id()) {
+    case blink::WebCryptoAlgorithmIdSha1:
+      *mechanism = CKM_SHA_1_HMAC;
+      return true;
+    case blink::WebCryptoAlgorithmIdSha256:
+      *mechanism = CKM_SHA256_HMAC;
+      return true;
+    case blink::WebCryptoAlgorithmIdSha384:
+      *mechanism = CKM_SHA384_HMAC;
+      return true;
+    case blink::WebCryptoAlgorithmIdSha512:
+      *mechanism = CKM_SHA512_HMAC;
+      return true;
+    default:
+      return false;
+  }
+}
+
+class HmacImplementation : public AlgorithmImplementation {
+ public:
+  HmacImplementation() {}
+
+  Status GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                     bool extractable,
+                     blink::WebCryptoKeyUsageMask usages,
+                     GenerateKeyResult* result) const override {
+    Status status = CheckKeyCreationUsages(kAllKeyUsages, usages, false);
+    if (status.IsError())
+      return status;
+
+    const blink::WebCryptoHmacKeyGenParams* params =
+        algorithm.hmacKeyGenParams();
+
+    const blink::WebCryptoAlgorithm& hash = params->hash();
+    CK_MECHANISM_TYPE mechanism = CKM_INVALID_MECHANISM;
+    if (!WebCryptoHashToHMACMechanism(hash, &mechanism))
+      return Status::ErrorUnsupported();
+
+    unsigned int keylen_bits = 0;
+    status = GetHmacKeyGenLengthInBits(params, &keylen_bits);
+    if (status.IsError())
+      return status;
+
+    return GenerateSecretKeyNss(
+        blink::WebCryptoKeyAlgorithm::createHmac(hash.id(), keylen_bits),
+        extractable, usages, keylen_bits, mechanism, result);
+  }
+
+  Status VerifyKeyUsagesBeforeImportKey(
+      blink::WebCryptoKeyFormat format,
+      blink::WebCryptoKeyUsageMask usages) const override {
+    switch (format) {
+      case blink::WebCryptoKeyFormatRaw:
+      case blink::WebCryptoKeyFormatJwk:
+        return CheckKeyCreationUsages(kAllKeyUsages, usages, false);
+      default:
+        return Status::ErrorUnsupportedImportKeyFormat();
+    }
+  }
+
+  Status ImportKeyRaw(const CryptoData& key_data,
+                      const blink::WebCryptoAlgorithm& algorithm,
+                      bool extractable,
+                      blink::WebCryptoKeyUsageMask usages,
+                      blink::WebCryptoKey* key) const override {
+    const blink::WebCryptoHmacImportParams* params =
+        algorithm.hmacImportParams();
+
+    CK_MECHANISM_TYPE mechanism = CKM_INVALID_MECHANISM;
+    if (!WebCryptoHashToHMACMechanism(params->hash(), &mechanism))
+      return Status::ErrorUnsupported();
+
+    unsigned int keylen_bits = 0;
+    Status status = GetHmacImportKeyLengthBits(params, key_data.byte_length(),
+                                               &keylen_bits);
+    if (status.IsError())
+      return status;
+
+    const blink::WebCryptoKeyAlgorithm key_algorithm =
+        blink::WebCryptoKeyAlgorithm::createHmac(params->hash().id(),
+                                                 keylen_bits);
+
+    // If no bit truncation was requested, then done!
+    if ((keylen_bits % 8) == 0) {
+      return ImportKeyRawNss(key_data, key_algorithm, extractable, usages,
+                             mechanism, key);
+    }
+
+    // Otherwise zero out the unused bits in the key data before importing.
+    std::vector<uint8_t> modified_key_data(
+        key_data.bytes(), key_data.bytes() + key_data.byte_length());
+    TruncateToBitLength(keylen_bits, &modified_key_data);
+    return ImportKeyRawNss(CryptoData(modified_key_data), key_algorithm,
+                           extractable, usages, mechanism, key);
+  }
+
+  Status ImportKeyJwk(const CryptoData& key_data,
+                      const blink::WebCryptoAlgorithm& algorithm,
+                      bool extractable,
+                      blink::WebCryptoKeyUsageMask usages,
+                      blink::WebCryptoKey* key) const override {
+    const char* algorithm_name =
+        GetJwkHmacAlgorithmName(algorithm.hmacImportParams()->hash().id());
+    if (!algorithm_name)
+      return Status::ErrorUnexpected();
+
+    std::vector<uint8_t> raw_data;
+    Status status = ReadSecretKeyJwk(key_data, algorithm_name, extractable,
+                                     usages, &raw_data);
+    if (status.IsError())
+      return status;
+
+    return ImportKeyRaw(CryptoData(raw_data), algorithm, extractable, usages,
+                        key);
+  }
+
+  Status ExportKeyRaw(const blink::WebCryptoKey& key,
+                      std::vector<uint8_t>* buffer) const override {
+    *buffer = SymKeyNss::Cast(key)->raw_key_data();
+    return Status::Success();
+  }
+
+  Status ExportKeyJwk(const blink::WebCryptoKey& key,
+                      std::vector<uint8_t>* buffer) const override {
+    SymKeyNss* sym_key = SymKeyNss::Cast(key);
+    const std::vector<uint8_t>& raw_data = sym_key->raw_key_data();
+
+    const char* algorithm_name =
+        GetJwkHmacAlgorithmName(key.algorithm().hmacParams()->hash().id());
+    if (!algorithm_name)
+      return Status::ErrorUnexpected();
+
+    WriteSecretKeyJwk(CryptoData(raw_data), algorithm_name, key.extractable(),
+                      key.usages(), buffer);
+
+    return Status::Success();
+  }
+
+  Status Sign(const blink::WebCryptoAlgorithm& algorithm,
+              const blink::WebCryptoKey& key,
+              const CryptoData& data,
+              std::vector<uint8_t>* buffer) const override {
+    const blink::WebCryptoAlgorithm& hash =
+        key.algorithm().hmacParams()->hash();
+    PK11SymKey* sym_key = SymKeyNss::Cast(key)->key();
+
+    CK_MECHANISM_TYPE mechanism = CKM_INVALID_MECHANISM;
+    if (!WebCryptoHashToHMACMechanism(hash, &mechanism))
+      return Status::ErrorUnexpected();
+
+    SECItem param_item = {siBuffer, NULL, 0};
+    SECItem data_item = MakeSECItemForBuffer(data);
+    // First call is to figure out the length.
+    SECItem signature_item = {siBuffer, NULL, 0};
+
+    if (PK11_SignWithSymKey(sym_key, mechanism, &param_item, &signature_item,
+                            &data_item) != SECSuccess) {
+      return Status::OperationError();
+    }
+
+    DCHECK_NE(0u, signature_item.len);
+
+    buffer->resize(signature_item.len);
+    signature_item.data = buffer->data();
+
+    if (PK11_SignWithSymKey(sym_key, mechanism, &param_item, &signature_item,
+                            &data_item) != SECSuccess) {
+      return Status::OperationError();
+    }
+
+    CHECK_EQ(buffer->size(), signature_item.len);
+    return Status::Success();
+  }
+
+  Status Verify(const blink::WebCryptoAlgorithm& algorithm,
+                const blink::WebCryptoKey& key,
+                const CryptoData& signature,
+                const CryptoData& data,
+                bool* signature_match) const override {
+    std::vector<uint8_t> result;
+    Status status = Sign(algorithm, key, data, &result);
+
+    if (status.IsError())
+      return status;
+
+    // Do not allow verification of truncated MACs.
+    *signature_match =
+        result.size() == signature.byte_length() &&
+        crypto::SecureMemEqual(result.data(), signature.bytes(),
+                               signature.byte_length());
+
+    return Status::Success();
+  }
+
+  Status SerializeKeyForClone(
+      const blink::WebCryptoKey& key,
+      blink::WebVector<uint8_t>* key_data) const override {
+    key_data->assign(SymKeyNss::Cast(key)->serialized_key_data());
+    return Status::Success();
+  }
+
+  Status DeserializeKeyForClone(const blink::WebCryptoKeyAlgorithm& algorithm,
+                                blink::WebCryptoKeyType type,
+                                bool extractable,
+                                blink::WebCryptoKeyUsageMask usages,
+                                const CryptoData& key_data,
+                                blink::WebCryptoKey* key) const override {
+    CK_MECHANISM_TYPE mechanism = CKM_INVALID_MECHANISM;
+    if (!WebCryptoHashToHMACMechanism(algorithm.hmacParams()->hash(),
+                                      &mechanism))
+      return Status::ErrorUnsupported();
+    return ImportKeyRawNss(key_data, algorithm, extractable, usages, mechanism,
+                           key);
+  }
+
+  Status GetKeyLength(const blink::WebCryptoAlgorithm& key_length_algorithm,
+                      bool* has_length_bits,
+                      unsigned int* length_bits) const override {
+    return GetHmacKeyLength(key_length_algorithm, has_length_bits, length_bits);
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformHmacImplementation() {
+  return new HmacImplementation;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/key_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,85 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/nss/key_nss.h"
+
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+
+namespace webcrypto {
+
+KeyNss::KeyNss(const CryptoData& serialized_key_data)
+    : serialized_key_data_(
+          serialized_key_data.bytes(),
+          serialized_key_data.bytes() + serialized_key_data.byte_length()) {
+}
+
+KeyNss::~KeyNss() {
+}
+
+SymKeyNss* KeyNss::AsSymKey() {
+  return NULL;
+}
+
+PublicKeyNss* KeyNss::AsPublicKey() {
+  return NULL;
+}
+
+PrivateKeyNss* KeyNss::AsPrivateKey() {
+  return NULL;
+}
+
+SymKeyNss::~SymKeyNss() {
+}
+
+SymKeyNss* SymKeyNss::Cast(const blink::WebCryptoKey& key) {
+  KeyNss* platform_key = reinterpret_cast<KeyNss*>(key.handle());
+  return platform_key->AsSymKey();
+}
+
+SymKeyNss* SymKeyNss::AsSymKey() {
+  return this;
+}
+
+SymKeyNss::SymKeyNss(crypto::ScopedPK11SymKey key,
+                     const CryptoData& raw_key_data)
+    : KeyNss(raw_key_data), key_(key.Pass()) {
+}
+
+PublicKeyNss::~PublicKeyNss() {
+}
+
+PublicKeyNss* PublicKeyNss::Cast(const blink::WebCryptoKey& key) {
+  KeyNss* platform_key = reinterpret_cast<KeyNss*>(key.handle());
+  return platform_key->AsPublicKey();
+}
+
+PublicKeyNss* PublicKeyNss::AsPublicKey() {
+  return this;
+}
+
+PublicKeyNss::PublicKeyNss(crypto::ScopedSECKEYPublicKey key,
+                           const CryptoData& spki_data)
+    : KeyNss(spki_data), key_(key.Pass()) {
+}
+
+PrivateKeyNss::~PrivateKeyNss() {
+}
+
+PrivateKeyNss* PrivateKeyNss::Cast(const blink::WebCryptoKey& key) {
+  KeyNss* platform_key = reinterpret_cast<KeyNss*>(key.handle());
+  return platform_key->AsPrivateKey();
+}
+
+PrivateKeyNss* PrivateKeyNss::AsPrivateKey() {
+  return this;
+}
+
+PrivateKeyNss::PrivateKeyNss(crypto::ScopedSECKEYPrivateKey key,
+                             const CryptoData& pkcs8_data)
+    : KeyNss(pkcs8_data), key_(key.Pass()) {
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/key_nss.h	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,105 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_NSS_KEY_NSS_H_
+#define COMPONENTS_WEBCRYPTO_NSS_KEY_NSS_H_
+
+#include <stdint.h>
+#include <vector>
+
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoKey.h"
+
+namespace webcrypto {
+
+class CryptoData;
+class PrivateKeyNss;
+class PublicKeyNss;
+class SymKeyNss;
+
+// Base key class for all NSS keys, used to safely cast between types. Each key
+// maintains a copy of its serialized form in either 'raw', 'pkcs8', or 'spki'
+// format. This is to allow structured cloning of keys synchronously from the
+// target Blink thread without having to lock access to the key.
+class KeyNss : public blink::WebCryptoKeyHandle {
+ public:
+  explicit KeyNss(const CryptoData& serialized_key_data);
+  ~KeyNss() override;
+
+  virtual SymKeyNss* AsSymKey();
+  virtual PublicKeyNss* AsPublicKey();
+  virtual PrivateKeyNss* AsPrivateKey();
+
+  const std::vector<uint8_t>& serialized_key_data() const {
+    return serialized_key_data_;
+  }
+
+ private:
+  const std::vector<uint8_t> serialized_key_data_;
+};
+
+class SymKeyNss : public KeyNss {
+ public:
+  ~SymKeyNss() override;
+  SymKeyNss(crypto::ScopedPK11SymKey key, const CryptoData& raw_key_data);
+
+  static SymKeyNss* Cast(const blink::WebCryptoKey& key);
+
+  PK11SymKey* key() { return key_.get(); }
+  SymKeyNss* AsSymKey() override;
+
+  const std::vector<uint8_t>& raw_key_data() const {
+    return serialized_key_data();
+  }
+
+ private:
+  crypto::ScopedPK11SymKey key_;
+
+  DISALLOW_COPY_AND_ASSIGN(SymKeyNss);
+};
+
+class PublicKeyNss : public KeyNss {
+ public:
+  ~PublicKeyNss() override;
+  PublicKeyNss(crypto::ScopedSECKEYPublicKey key, const CryptoData& spki_data);
+
+  static PublicKeyNss* Cast(const blink::WebCryptoKey& key);
+
+  SECKEYPublicKey* key() { return key_.get(); }
+  PublicKeyNss* AsPublicKey() override;
+
+  const std::vector<uint8_t>& spki_data() const {
+    return serialized_key_data();
+  }
+
+ private:
+  crypto::ScopedSECKEYPublicKey key_;
+
+  DISALLOW_COPY_AND_ASSIGN(PublicKeyNss);
+};
+
+class PrivateKeyNss : public KeyNss {
+ public:
+  ~PrivateKeyNss() override;
+  PrivateKeyNss(crypto::ScopedSECKEYPrivateKey key,
+                const CryptoData& pkcs8_data);
+
+  static PrivateKeyNss* Cast(const blink::WebCryptoKey& key);
+
+  SECKEYPrivateKey* key() { return key_.get(); }
+  PrivateKeyNss* AsPrivateKey() override;
+
+  const std::vector<uint8_t>& pkcs8_data() const {
+    return serialized_key_data();
+  }
+
+ private:
+  crypto::ScopedSECKEYPrivateKey key_;
+
+  DISALLOW_COPY_AND_ASSIGN(PrivateKeyNss);
+};
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_NSS_KEY_NSS_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/rsa_hashed_algorithm_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,858 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/nss/rsa_hashed_algorithm_nss.h"
+
+#include <secasn1.h>
+
+#include "base/logging.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/generate_key_result.h"
+#include "components/webcrypto/jwk.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+#if defined(USE_NSS_CERTS) && !defined(OS_CHROMEOS)
+Status ErrorRsaPrivateKeyImportNotSupported() {
+  return Status::ErrorUnsupported(
+      "NSS version must be at least 3.16.2 for RSA private key import. See "
+      "http://crbug.com/380424");
+}
+
+// Prior to NSS 3.16.2 RSA key parameters were not validated. This is
+// a security problem for RSA private key import from JWK which uses a
+// CKA_ID based on the public modulus to retrieve the private key.
+Status NssSupportsRsaPrivateKeyImport() {
+  if (!NSS_VersionCheck("3.16.2"))
+    return ErrorRsaPrivateKeyImportNotSupported();
+
+  // Also ensure that the version of Softoken is 3.16.2 or later.
+  crypto::ScopedPK11Slot slot(PK11_GetInternalSlot());
+  CK_SLOT_INFO info = {};
+  if (PK11_GetSlotInfo(slot.get(), &info) != SECSuccess)
+    return ErrorRsaPrivateKeyImportNotSupported();
+
+  // CK_SLOT_INFO.hardwareVersion contains the major.minor
+  // version info for Softoken in the corresponding .major/.minor
+  // fields, and .firmwareVersion contains the patch.build
+  // version info (in the .major/.minor fields)
+  if ((info.hardwareVersion.major > 3) ||
+      (info.hardwareVersion.major == 3 &&
+       (info.hardwareVersion.minor > 16 ||
+        (info.hardwareVersion.minor == 16 &&
+         info.firmwareVersion.major >= 2)))) {
+    return Status::Success();
+  }
+
+  return ErrorRsaPrivateKeyImportNotSupported();
+}
+#else
+Status NssSupportsRsaPrivateKeyImport() {
+  return Status::Success();
+}
+#endif
+
+bool CreateRsaHashedPublicKeyAlgorithm(
+    blink::WebCryptoAlgorithmId rsa_algorithm,
+    blink::WebCryptoAlgorithmId hash_algorithm,
+    SECKEYPublicKey* key,
+    blink::WebCryptoKeyAlgorithm* key_algorithm) {
+  // TODO(eroman): What about other key types rsaPss, rsaOaep.
+  if (!key || key->keyType != rsaKey)
+    return false;
+
+  unsigned int modulus_length_bits = SECKEY_PublicKeyStrength(key) * 8;
+  CryptoData public_exponent(key->u.rsa.publicExponent.data,
+                             key->u.rsa.publicExponent.len);
+
+  *key_algorithm = blink::WebCryptoKeyAlgorithm::createRsaHashed(
+      rsa_algorithm, modulus_length_bits, public_exponent.bytes(),
+      public_exponent.byte_length(), hash_algorithm);
+  return true;
+}
+
+bool CreateRsaHashedPrivateKeyAlgorithm(
+    blink::WebCryptoAlgorithmId rsa_algorithm,
+    blink::WebCryptoAlgorithmId hash_algorithm,
+    SECKEYPrivateKey* key,
+    blink::WebCryptoKeyAlgorithm* key_algorithm) {
+  crypto::ScopedSECKEYPublicKey public_key(SECKEY_ConvertToPublicKey(key));
+  if (!public_key)
+    return false;
+  return CreateRsaHashedPublicKeyAlgorithm(rsa_algorithm, hash_algorithm,
+                                           public_key.get(), key_algorithm);
+}
+
+// From PKCS#1 [http://tools.ietf.org/html/rfc3447]:
+//
+//    RSAPrivateKey ::= SEQUENCE {
+//      version           Version,
+//      modulus           INTEGER,  -- n
+//      publicExponent    INTEGER,  -- e
+//      privateExponent   INTEGER,  -- d
+//      prime1            INTEGER,  -- p
+//      prime2            INTEGER,  -- q
+//      exponent1         INTEGER,  -- d mod (p-1)
+//      exponent2         INTEGER,  -- d mod (q-1)
+//      coefficient       INTEGER,  -- (inverse of q) mod p
+//      otherPrimeInfos   OtherPrimeInfos OPTIONAL
+//    }
+//
+// Note that otherPrimeInfos is only applicable for version=1. Since NSS
+// doesn't use multi-prime can safely use version=0.
+struct RSAPrivateKey {
+  SECItem version;
+  SECItem modulus;
+  SECItem public_exponent;
+  SECItem private_exponent;
+  SECItem prime1;
+  SECItem prime2;
+  SECItem exponent1;
+  SECItem exponent2;
+  SECItem coefficient;
+};
+
+// The system NSS library doesn't have the new PK11_ExportDERPrivateKeyInfo
+// function yet (https://bugzilla.mozilla.org/show_bug.cgi?id=519255). So we
+// provide a fallback implementation.
+#if defined(USE_NSS_CERTS)
+const SEC_ASN1Template RSAPrivateKeyTemplate[] = {
+    {SEC_ASN1_SEQUENCE, 0, NULL, sizeof(RSAPrivateKey)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, version)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, modulus)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, public_exponent)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, private_exponent)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, prime1)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, prime2)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, exponent1)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, exponent2)},
+    {SEC_ASN1_INTEGER, offsetof(RSAPrivateKey, coefficient)},
+    {0}};
+#endif  // defined(USE_NSS_CERTS)
+
+// On success |value| will be filled with data which must be freed by
+// SECITEM_FreeItem(value, PR_FALSE);
+bool ReadUint(SECKEYPrivateKey* key,
+              CK_ATTRIBUTE_TYPE attribute,
+              SECItem* value) {
+  SECStatus rv = PK11_ReadRawAttribute(PK11_TypePrivKey, key, attribute, value);
+
+  // PK11_ReadRawAttribute() returns items of type siBuffer. However in order
+  // for the ASN.1 encoding to be correct, the items must be of type
+  // siUnsignedInteger.
+  value->type = siUnsignedInteger;
+
+  return rv == SECSuccess;
+}
+
+// Fills |out| with the RSA private key properties. Returns true on success.
+// Regardless of the return value, the caller must invoke FreeRSAPrivateKey()
+// to free up any allocated memory.
+//
+// The passed in RSAPrivateKey must be zero-initialized.
+bool InitRSAPrivateKey(SECKEYPrivateKey* key, RSAPrivateKey* out) {
+  if (key->keyType != rsaKey)
+    return false;
+
+  // Everything should be zero-ed out. These are just some spot checks.
+  DCHECK(!out->version.data);
+  DCHECK(!out->version.len);
+  DCHECK(!out->modulus.data);
+  DCHECK(!out->modulus.len);
+
+  // Always use version=0 since not using multi-prime.
+  if (!SEC_ASN1EncodeInteger(NULL, &out->version, 0))
+    return false;
+
+  if (!ReadUint(key, CKA_MODULUS, &out->modulus))
+    return false;
+  if (!ReadUint(key, CKA_PUBLIC_EXPONENT, &out->public_exponent))
+    return false;
+  if (!ReadUint(key, CKA_PRIVATE_EXPONENT, &out->private_exponent))
+    return false;
+  if (!ReadUint(key, CKA_PRIME_1, &out->prime1))
+    return false;
+  if (!ReadUint(key, CKA_PRIME_2, &out->prime2))
+    return false;
+  if (!ReadUint(key, CKA_EXPONENT_1, &out->exponent1))
+    return false;
+  if (!ReadUint(key, CKA_EXPONENT_2, &out->exponent2))
+    return false;
+  if (!ReadUint(key, CKA_COEFFICIENT, &out->coefficient))
+    return false;
+
+  return true;
+}
+
+struct FreeRsaPrivateKey {
+  void operator()(RSAPrivateKey* out) {
+    SECITEM_FreeItem(&out->version, PR_FALSE);
+    SECITEM_FreeItem(&out->modulus, PR_FALSE);
+    SECITEM_FreeItem(&out->public_exponent, PR_FALSE);
+    SECITEM_FreeItem(&out->private_exponent, PR_FALSE);
+    SECITEM_FreeItem(&out->prime1, PR_FALSE);
+    SECITEM_FreeItem(&out->prime2, PR_FALSE);
+    SECITEM_FreeItem(&out->exponent1, PR_FALSE);
+    SECITEM_FreeItem(&out->exponent2, PR_FALSE);
+    SECITEM_FreeItem(&out->coefficient, PR_FALSE);
+  }
+};
+
+typedef scoped_ptr<CERTSubjectPublicKeyInfo,
+                   crypto::NSSDestroyer<CERTSubjectPublicKeyInfo,
+                                        SECKEY_DestroySubjectPublicKeyInfo>>
+    ScopedCERTSubjectPublicKeyInfo;
+
+struct DestroyGenericObject {
+  void operator()(PK11GenericObject* o) const {
+    if (o)
+      PK11_DestroyGenericObject(o);
+  }
+};
+
+typedef scoped_ptr<PK11GenericObject, DestroyGenericObject>
+    ScopedPK11GenericObject;
+
+// Helper to add an attribute to a template.
+void AddAttribute(CK_ATTRIBUTE_TYPE type,
+                  void* value,
+                  unsigned long length,
+                  std::vector<CK_ATTRIBUTE>* templ) {
+  CK_ATTRIBUTE attribute = {type, value, length};
+  templ->push_back(attribute);
+}
+
+void AddAttribute(CK_ATTRIBUTE_TYPE type,
+                  const CryptoData& data,
+                  std::vector<CK_ATTRIBUTE>* templ) {
+  CK_ATTRIBUTE attribute = {
+      type, const_cast<unsigned char*>(data.bytes()), data.byte_length()};
+  templ->push_back(attribute);
+}
+
+void AddAttribute(CK_ATTRIBUTE_TYPE type,
+                  const std::string& data,
+                  std::vector<CK_ATTRIBUTE>* templ) {
+  AddAttribute(type, CryptoData(data), templ);
+}
+
+Status ExportKeyPkcs8Nss(SECKEYPrivateKey* key, std::vector<uint8_t>* buffer) {
+  if (key->keyType != rsaKey)
+    return Status::ErrorUnsupported();
+
+// TODO(rsleevi): Implement OAEP support according to the spec.
+
+#if defined(USE_NSS_CERTS)
+  // PK11_ExportDERPrivateKeyInfo isn't available. Use our fallback code.
+  const SECOidTag algorithm = SEC_OID_PKCS1_RSA_ENCRYPTION;
+  const int kPrivateKeyInfoVersion = 0;
+
+  SECKEYPrivateKeyInfo private_key_info = {};
+  RSAPrivateKey rsa_private_key = {};
+  scoped_ptr<RSAPrivateKey, FreeRsaPrivateKey> free_private_key(
+      &rsa_private_key);
+
+  // http://crbug.com/366427: the spec does not define any other failures for
+  // exporting, so none of the subsequent errors are spec compliant.
+  if (!InitRSAPrivateKey(key, &rsa_private_key))
+    return Status::OperationError();
+
+  crypto::ScopedPLArenaPool arena(PORT_NewArena(DER_DEFAULT_CHUNKSIZE));
+  if (!arena.get())
+    return Status::OperationError();
+
+  if (!SEC_ASN1EncodeItem(arena.get(), &private_key_info.privateKey,
+                          &rsa_private_key, RSAPrivateKeyTemplate)) {
+    return Status::OperationError();
+  }
+
+  if (SECSuccess != SECOID_SetAlgorithmID(arena.get(),
+                                          &private_key_info.algorithm,
+                                          algorithm, NULL)) {
+    return Status::OperationError();
+  }
+
+  if (!SEC_ASN1EncodeInteger(arena.get(), &private_key_info.version,
+                             kPrivateKeyInfoVersion)) {
+    return Status::OperationError();
+  }
+
+  crypto::ScopedSECItem encoded_key(
+      SEC_ASN1EncodeItem(NULL, NULL, &private_key_info,
+                         SEC_ASN1_GET(SECKEY_PrivateKeyInfoTemplate)));
+#else   // defined(USE_NSS_CERTS)
+  crypto::ScopedSECItem encoded_key(PK11_ExportDERPrivateKeyInfo(key, NULL));
+#endif  // defined(USE_NSS_CERTS)
+
+  if (!encoded_key.get())
+    return Status::OperationError();
+
+  buffer->assign(encoded_key->data, encoded_key->data + encoded_key->len);
+  return Status::Success();
+}
+
+Status ImportRsaPrivateKey(const blink::WebCryptoAlgorithm& algorithm,
+                           bool extractable,
+                           blink::WebCryptoKeyUsageMask usages,
+                           const JwkRsaInfo& params,
+                           blink::WebCryptoKey* key) {
+  Status status = NssSupportsRsaPrivateKeyImport();
+  if (status.IsError())
+    return status;
+
+  CK_OBJECT_CLASS obj_class = CKO_PRIVATE_KEY;
+  CK_KEY_TYPE key_type = CKK_RSA;
+  CK_BBOOL ck_false = CK_FALSE;
+
+  std::vector<CK_ATTRIBUTE> key_template;
+
+  AddAttribute(CKA_CLASS, &obj_class, sizeof(obj_class), &key_template);
+  AddAttribute(CKA_KEY_TYPE, &key_type, sizeof(key_type), &key_template);
+  AddAttribute(CKA_TOKEN, &ck_false, sizeof(ck_false), &key_template);
+  AddAttribute(CKA_SENSITIVE, &ck_false, sizeof(ck_false), &key_template);
+  AddAttribute(CKA_PRIVATE, &ck_false, sizeof(ck_false), &key_template);
+
+  // Required properties by JWA.
+  AddAttribute(CKA_MODULUS, params.n, &key_template);
+  AddAttribute(CKA_PUBLIC_EXPONENT, params.e, &key_template);
+  AddAttribute(CKA_PRIVATE_EXPONENT, params.d, &key_template);
+
+  // Manufacture a CKA_ID so the created key can be retrieved later as a
+  // SECKEYPrivateKey using FindKeyByKeyID(). Unfortunately there isn't a more
+  // direct way to do this in NSS.
+  //
+  // For consistency with other NSS key creation methods, set the CKA_ID to
+  // PK11_MakeIDFromPubKey(). There are some problems with
+  // this approach:
+  //
+  //  (1) Prior to NSS 3.16.2, there is no parameter validation when creating
+  //      private keys. It is therefore possible to construct a key using the
+  //      known public modulus, and where all the other parameters are bogus.
+  //      FindKeyByKeyID() returns the first key matching the ID. So this would
+  //      effectively allow an attacker to retrieve a private key of their
+  //      choice.
+  //
+  //  (2) The ID space is shared by different key types. So theoretically
+  //      possible to retrieve a key of the wrong type which has a matching
+  //      CKA_ID. In practice I am told this is not likely except for small key
+  //      sizes, since would require constructing keys with the same public
+  //      data.
+  //
+  //  (3) FindKeyByKeyID() doesn't necessarily return the object that was just
+  //      created by CreateGenericObject. If the pre-existing key was
+  //      provisioned with flags incompatible with WebCrypto (for instance
+  //      marked sensitive) then this will break things.
+  SECItem modulus_item = MakeSECItemForBuffer(CryptoData(params.n));
+  crypto::ScopedSECItem object_id(PK11_MakeIDFromPubKey(&modulus_item));
+  AddAttribute(CKA_ID, CryptoData(object_id->data, object_id->len),
+               &key_template);
+
+  // Optional properties by JWA, however guaranteed to be present by Chromium's
+  // implementation.
+  AddAttribute(CKA_PRIME_1, params.p, &key_template);
+  AddAttribute(CKA_PRIME_2, params.q, &key_template);
+  AddAttribute(CKA_EXPONENT_1, params.dp, &key_template);
+  AddAttribute(CKA_EXPONENT_2, params.dq, &key_template);
+  AddAttribute(CKA_COEFFICIENT, params.qi, &key_template);
+
+  crypto::ScopedPK11Slot slot(PK11_GetInternalSlot());
+
+  ScopedPK11GenericObject key_object(PK11_CreateGenericObject(
+      slot.get(), &key_template[0], key_template.size(), PR_FALSE));
+
+  if (!key_object)
+    return Status::OperationError();
+
+  crypto::ScopedSECKEYPrivateKey private_key_tmp(
+      PK11_FindKeyByKeyID(slot.get(), object_id.get(), NULL));
+
+  // PK11_FindKeyByKeyID() may return a handle to an existing key, rather than
+  // the object created by PK11_CreateGenericObject().
+  crypto::ScopedSECKEYPrivateKey private_key(
+      SECKEY_CopyPrivateKey(private_key_tmp.get()));
+
+  if (!private_key)
+    return Status::OperationError();
+
+  blink::WebCryptoKeyAlgorithm key_algorithm;
+  if (!CreateRsaHashedPrivateKeyAlgorithm(
+          algorithm.id(), algorithm.rsaHashedImportParams()->hash().id(),
+          private_key.get(), &key_algorithm)) {
+    return Status::ErrorUnexpected();
+  }
+
+  std::vector<uint8_t> pkcs8_data;
+  status = ExportKeyPkcs8Nss(private_key.get(), &pkcs8_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PrivateKeyNss> key_handle(
+      new PrivateKeyNss(private_key.Pass(), CryptoData(pkcs8_data)));
+
+  *key = blink::WebCryptoKey::create(key_handle.release(),
+                                     blink::WebCryptoKeyTypePrivate,
+                                     extractable, key_algorithm, usages);
+  return Status::Success();
+}
+
+Status ExportKeySpkiNss(SECKEYPublicKey* key, std::vector<uint8_t>* buffer) {
+  const crypto::ScopedSECItem spki_der(
+      SECKEY_EncodeDERSubjectPublicKeyInfo(key));
+  if (!spki_der)
+    return Status::OperationError();
+
+  buffer->assign(spki_der->data, spki_der->data + spki_der->len);
+  return Status::Success();
+}
+
+Status ImportRsaPublicKey(const blink::WebCryptoAlgorithm& algorithm,
+                          bool extractable,
+                          blink::WebCryptoKeyUsageMask usages,
+                          const CryptoData& modulus_data,
+                          const CryptoData& exponent_data,
+                          blink::WebCryptoKey* key) {
+  if (!modulus_data.byte_length())
+    return Status::ErrorImportRsaEmptyModulus();
+
+  if (!exponent_data.byte_length())
+    return Status::ErrorImportRsaEmptyExponent();
+
+  DCHECK(modulus_data.bytes());
+  DCHECK(exponent_data.bytes());
+
+  // NSS does not provide a way to create an RSA public key directly from the
+  // modulus and exponent values, but it can import an DER-encoded ASN.1 blob
+  // with these values and create the public key from that. The code below
+  // follows the recommendation described in
+  // https://developer.mozilla.org/en-US/docs/NSS/NSS_Tech_Notes/nss_tech_note7
+
+  // Pack the input values into a struct compatible with NSS ASN.1 encoding, and
+  // set up an ASN.1 encoder template for it.
+  struct RsaPublicKeyData {
+    SECItem modulus;
+    SECItem exponent;
+  };
+  const RsaPublicKeyData pubkey_in = {
+      {siUnsignedInteger,
+       const_cast<unsigned char*>(modulus_data.bytes()),
+       modulus_data.byte_length()},
+      {siUnsignedInteger,
+       const_cast<unsigned char*>(exponent_data.bytes()),
+       exponent_data.byte_length()}};
+  const SEC_ASN1Template rsa_public_key_template[] = {
+      {SEC_ASN1_SEQUENCE, 0, NULL, sizeof(RsaPublicKeyData)},
+      {
+       SEC_ASN1_INTEGER, offsetof(RsaPublicKeyData, modulus),
+      },
+      {
+       SEC_ASN1_INTEGER, offsetof(RsaPublicKeyData, exponent),
+      },
+      {
+       0, }};
+
+  // DER-encode the public key.
+  crypto::ScopedSECItem pubkey_der(
+      SEC_ASN1EncodeItem(NULL, NULL, &pubkey_in, rsa_public_key_template));
+  if (!pubkey_der)
+    return Status::OperationError();
+
+  // Import the DER-encoded public key to create an RSA SECKEYPublicKey.
+  crypto::ScopedSECKEYPublicKey pubkey(
+      SECKEY_ImportDERPublicKey(pubkey_der.get(), CKK_RSA));
+  if (!pubkey)
+    return Status::OperationError();
+
+  blink::WebCryptoKeyAlgorithm key_algorithm;
+  if (!CreateRsaHashedPublicKeyAlgorithm(
+          algorithm.id(), algorithm.rsaHashedImportParams()->hash().id(),
+          pubkey.get(), &key_algorithm)) {
+    return Status::ErrorUnexpected();
+  }
+
+  std::vector<uint8_t> spki_data;
+  Status status = ExportKeySpkiNss(pubkey.get(), &spki_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PublicKeyNss> key_handle(
+      new PublicKeyNss(pubkey.Pass(), CryptoData(spki_data)));
+
+  *key = blink::WebCryptoKey::create(key_handle.release(),
+                                     blink::WebCryptoKeyTypePublic, extractable,
+                                     key_algorithm, usages);
+  return Status::Success();
+}
+
+}  // namespace
+
+Status RsaHashedAlgorithm::GenerateKey(
+    const blink::WebCryptoAlgorithm& algorithm,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask combined_usages,
+    GenerateKeyResult* result) const {
+  blink::WebCryptoKeyUsageMask public_usages = 0;
+  blink::WebCryptoKeyUsageMask private_usages = 0;
+
+  Status status = GetUsagesForGenerateAsymmetricKey(
+      combined_usages, all_public_key_usages_, all_private_key_usages_,
+      &public_usages, &private_usages);
+  if (status.IsError())
+    return status;
+
+  unsigned int public_exponent = 0;
+  unsigned int modulus_length_bits = 0;
+  status = GetRsaKeyGenParameters(algorithm.rsaHashedKeyGenParams(),
+                                  &public_exponent, &modulus_length_bits);
+  if (status.IsError())
+    return status;
+
+  crypto::ScopedPK11Slot slot(PK11_GetInternalKeySlot());
+  if (!slot)
+    return Status::OperationError();
+
+  PK11RSAGenParams rsa_gen_params;
+  rsa_gen_params.keySizeInBits = modulus_length_bits;
+  rsa_gen_params.pe = public_exponent;
+
+  // The usages are enforced at the WebCrypto layer, so it isn't necessary to
+  // create keys with limited usages.
+  const CK_FLAGS operation_flags_mask = kAllOperationFlags;
+
+  // The private key must be marked as insensitive and extractable, otherwise it
+  // cannot later be exported in unencrypted form or structured-cloned.
+  const PK11AttrFlags attribute_flags =
+      PK11_ATTR_INSENSITIVE | PK11_ATTR_EXTRACTABLE;
+
+  // Note: NSS does not generate an sec_public_key if the call below fails,
+  // so there is no danger of a leaked sec_public_key.
+  SECKEYPublicKey* sec_public_key;
+  crypto::ScopedSECKEYPrivateKey scoped_sec_private_key(
+      PK11_GenerateKeyPairWithOpFlags(slot.get(), CKM_RSA_PKCS_KEY_PAIR_GEN,
+                                      &rsa_gen_params, &sec_public_key,
+                                      attribute_flags, generate_flags_,
+                                      operation_flags_mask, NULL));
+  if (!scoped_sec_private_key)
+    return Status::OperationError();
+
+  blink::WebCryptoKeyAlgorithm key_algorithm;
+  if (!CreateRsaHashedPublicKeyAlgorithm(
+          algorithm.id(), algorithm.rsaHashedKeyGenParams()->hash().id(),
+          sec_public_key, &key_algorithm)) {
+    return Status::ErrorUnexpected();
+  }
+
+  std::vector<uint8_t> spki_data;
+  status = ExportKeySpkiNss(sec_public_key, &spki_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PublicKeyNss> public_key_handle(new PublicKeyNss(
+      crypto::ScopedSECKEYPublicKey(sec_public_key), CryptoData(spki_data)));
+
+  std::vector<uint8_t> pkcs8_data;
+  status = ExportKeyPkcs8Nss(scoped_sec_private_key.get(), &pkcs8_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PrivateKeyNss> private_key_handle(
+      new PrivateKeyNss(scoped_sec_private_key.Pass(), CryptoData(pkcs8_data)));
+
+  blink::WebCryptoKey public_key = blink::WebCryptoKey::create(
+      public_key_handle.release(), blink::WebCryptoKeyTypePublic, true,
+      key_algorithm, public_usages);
+
+  blink::WebCryptoKey private_key = blink::WebCryptoKey::create(
+      private_key_handle.release(), blink::WebCryptoKeyTypePrivate, extractable,
+      key_algorithm, private_usages);
+
+  result->AssignKeyPair(public_key, private_key);
+  return Status::Success();
+}
+
+Status RsaHashedAlgorithm::VerifyKeyUsagesBeforeImportKey(
+    blink::WebCryptoKeyFormat format,
+    blink::WebCryptoKeyUsageMask usages) const {
+  return VerifyUsagesBeforeImportAsymmetricKey(format, all_public_key_usages_,
+                                               all_private_key_usages_, usages);
+}
+
+Status RsaHashedAlgorithm::ImportKeyPkcs8(
+    const CryptoData& key_data,
+    const blink::WebCryptoAlgorithm& algorithm,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask usages,
+    blink::WebCryptoKey* key) const {
+  Status status = NssSupportsRsaPrivateKeyImport();
+  if (status.IsError())
+    return status;
+
+  crypto::ScopedPLArenaPool arena(PORT_NewArena(DER_DEFAULT_CHUNKSIZE));
+  if (!arena.get())
+    return Status::OperationError();
+
+  // The binary blob 'key_data' is expected to be a DER-encoded ASN.1 PKCS#8
+  // private key info object. Excess data is illegal, but NSS silently accepts
+  // it, so first ensure that 'key_data' consists of a single ASN.1 element.
+  SECItem key_item = MakeSECItemForBuffer(key_data);
+  SECItem pki_der;
+  if (SEC_QuickDERDecodeItem(arena.get(), &pki_der,
+                             SEC_ASN1_GET(SEC_AnyTemplate),
+                             &key_item) != SECSuccess) {
+    return Status::DataError();
+  }
+
+  SECKEYPrivateKey* seckey_private_key = NULL;
+  crypto::ScopedPK11Slot slot(PK11_GetInternalSlot());
+  if (PK11_ImportDERPrivateKeyInfoAndReturnKey(slot.get(), &pki_der,
+                                               NULL,    // nickname
+                                               NULL,    // publicValue
+                                               false,   // isPerm
+                                               false,   // isPrivate
+                                               KU_ALL,  // usage
+                                               &seckey_private_key,
+                                               NULL) != SECSuccess) {
+    return Status::DataError();
+  }
+  DCHECK(seckey_private_key);
+  crypto::ScopedSECKEYPrivateKey private_key(seckey_private_key);
+
+  const KeyType sec_key_type = SECKEY_GetPrivateKeyType(private_key.get());
+  if (sec_key_type != rsaKey)
+    return Status::DataError();
+
+  blink::WebCryptoKeyAlgorithm key_algorithm;
+  if (!CreateRsaHashedPrivateKeyAlgorithm(
+          algorithm.id(), algorithm.rsaHashedImportParams()->hash().id(),
+          private_key.get(), &key_algorithm)) {
+    return Status::ErrorUnexpected();
+  }
+
+  // TODO(eroman): This is probably going to be the same as the input.
+  std::vector<uint8_t> pkcs8_data;
+  status = ExportKeyPkcs8Nss(private_key.get(), &pkcs8_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PrivateKeyNss> key_handle(
+      new PrivateKeyNss(private_key.Pass(), CryptoData(pkcs8_data)));
+
+  *key = blink::WebCryptoKey::create(key_handle.release(),
+                                     blink::WebCryptoKeyTypePrivate,
+                                     extractable, key_algorithm, usages);
+
+  return Status::Success();
+}
+
+Status RsaHashedAlgorithm::ImportKeySpki(
+    const CryptoData& key_data,
+    const blink::WebCryptoAlgorithm& algorithm,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask usages,
+    blink::WebCryptoKey* key) const {
+  // The binary blob 'key_data' is expected to be a DER-encoded ASN.1 Subject
+  // Public Key Info. Decode this to a CERTSubjectPublicKeyInfo.
+  SECItem spki_item = MakeSECItemForBuffer(key_data);
+  const ScopedCERTSubjectPublicKeyInfo spki(
+      SECKEY_DecodeDERSubjectPublicKeyInfo(&spki_item));
+  if (!spki)
+    return Status::DataError();
+
+  crypto::ScopedSECKEYPublicKey sec_public_key(
+      SECKEY_ExtractPublicKey(spki.get()));
+  if (!sec_public_key)
+    return Status::DataError();
+
+  const KeyType sec_key_type = SECKEY_GetPublicKeyType(sec_public_key.get());
+  if (sec_key_type != rsaKey)
+    return Status::DataError();
+
+  blink::WebCryptoKeyAlgorithm key_algorithm;
+  if (!CreateRsaHashedPublicKeyAlgorithm(
+          algorithm.id(), algorithm.rsaHashedImportParams()->hash().id(),
+          sec_public_key.get(), &key_algorithm)) {
+    return Status::ErrorUnexpected();
+  }
+
+  // TODO(eroman): This is probably going to be the same as the input.
+  std::vector<uint8_t> spki_data;
+  Status status = ExportKeySpkiNss(sec_public_key.get(), &spki_data);
+  if (status.IsError())
+    return status;
+
+  scoped_ptr<PublicKeyNss> key_handle(
+      new PublicKeyNss(sec_public_key.Pass(), CryptoData(spki_data)));
+
+  *key = blink::WebCryptoKey::create(key_handle.release(),
+                                     blink::WebCryptoKeyTypePublic, extractable,
+                                     key_algorithm, usages);
+
+  return Status::Success();
+}
+
+Status RsaHashedAlgorithm::ExportKeyPkcs8(const blink::WebCryptoKey& key,
+                                          std::vector<uint8_t>* buffer) const {
+  if (key.type() != blink::WebCryptoKeyTypePrivate)
+    return Status::ErrorUnexpectedKeyType();
+  *buffer = PrivateKeyNss::Cast(key)->pkcs8_data();
+  return Status::Success();
+}
+
+Status RsaHashedAlgorithm::ExportKeySpki(const blink::WebCryptoKey& key,
+                                         std::vector<uint8_t>* buffer) const {
+  if (key.type() != blink::WebCryptoKeyTypePublic)
+    return Status::ErrorUnexpectedKeyType();
+  *buffer = PublicKeyNss::Cast(key)->spki_data();
+  return Status::Success();
+}
+
+Status RsaHashedAlgorithm::ImportKeyJwk(
+    const CryptoData& key_data,
+    const blink::WebCryptoAlgorithm& algorithm,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask usages,
+    blink::WebCryptoKey* key) const {
+  const char* jwk_algorithm =
+      GetJwkAlgorithm(algorithm.rsaHashedImportParams()->hash().id());
+
+  if (!jwk_algorithm)
+    return Status::ErrorUnexpected();
+
+  JwkRsaInfo jwk;
+  Status status =
+      ReadRsaKeyJwk(key_data, jwk_algorithm, extractable, usages, &jwk);
+  if (status.IsError())
+    return status;
+
+  // Once the key type is known, verify the usages.
+  status = CheckKeyCreationUsages(
+      jwk.is_private_key ? all_private_key_usages_ : all_public_key_usages_,
+      usages, !jwk.is_private_key);
+  if (status.IsError())
+    return status;
+
+  return jwk.is_private_key
+             ? ImportRsaPrivateKey(algorithm, extractable, usages, jwk, key)
+             : ImportRsaPublicKey(algorithm, extractable, usages,
+                                  CryptoData(jwk.n), CryptoData(jwk.e), key);
+}
+
+Status RsaHashedAlgorithm::ExportKeyJwk(const blink::WebCryptoKey& key,
+                                        std::vector<uint8_t>* buffer) const {
+  const char* jwk_algorithm =
+      GetJwkAlgorithm(key.algorithm().rsaHashedParams()->hash().id());
+
+  if (!jwk_algorithm)
+    return Status::ErrorUnexpected();
+
+  switch (key.type()) {
+    case blink::WebCryptoKeyTypePublic: {
+      SECKEYPublicKey* nss_key = PublicKeyNss::Cast(key)->key();
+      if (nss_key->keyType != rsaKey)
+        return Status::ErrorUnsupported();
+
+      WriteRsaPublicKeyJwk(SECItemToCryptoData(nss_key->u.rsa.modulus),
+                           SECItemToCryptoData(nss_key->u.rsa.publicExponent),
+                           jwk_algorithm, key.extractable(), key.usages(),
+                           buffer);
+
+      return Status::Success();
+    }
+
+    case blink::WebCryptoKeyTypePrivate: {
+      SECKEYPrivateKey* nss_key = PrivateKeyNss::Cast(key)->key();
+      RSAPrivateKey key_props = {};
+      scoped_ptr<RSAPrivateKey, FreeRsaPrivateKey> free_private_key(&key_props);
+
+      if (!InitRSAPrivateKey(nss_key, &key_props))
+        return Status::OperationError();
+
+      WriteRsaPrivateKeyJwk(SECItemToCryptoData(key_props.modulus),
+                            SECItemToCryptoData(key_props.public_exponent),
+                            SECItemToCryptoData(key_props.private_exponent),
+                            SECItemToCryptoData(key_props.prime1),
+                            SECItemToCryptoData(key_props.prime2),
+                            SECItemToCryptoData(key_props.exponent1),
+                            SECItemToCryptoData(key_props.exponent2),
+                            SECItemToCryptoData(key_props.coefficient),
+                            jwk_algorithm, key.extractable(), key.usages(),
+                            buffer);
+
+      return Status::Success();
+    }
+    default:
+      return Status::ErrorUnexpected();
+  }
+}
+
+Status RsaHashedAlgorithm::SerializeKeyForClone(
+    const blink::WebCryptoKey& key,
+    blink::WebVector<uint8_t>* key_data) const {
+  key_data->assign(static_cast<KeyNss*>(key.handle())->serialized_key_data());
+  return Status::Success();
+}
+
+// TODO(eroman): Defer import to the crypto thread. http://crbug.com/430763
+Status RsaHashedAlgorithm::DeserializeKeyForClone(
+    const blink::WebCryptoKeyAlgorithm& algorithm,
+    blink::WebCryptoKeyType type,
+    bool extractable,
+    blink::WebCryptoKeyUsageMask usages,
+    const CryptoData& key_data,
+    blink::WebCryptoKey* key) const {
+  blink::WebCryptoAlgorithm import_algorithm = CreateRsaHashedImportAlgorithm(
+      algorithm.id(), algorithm.rsaHashedParams()->hash().id());
+
+  Status status;
+
+  switch (type) {
+    case blink::WebCryptoKeyTypePublic:
+      status =
+          ImportKeySpki(key_data, import_algorithm, extractable, usages, key);
+      break;
+    case blink::WebCryptoKeyTypePrivate:
+      status =
+          ImportKeyPkcs8(key_data, import_algorithm, extractable, usages, key);
+      break;
+    default:
+      return Status::ErrorUnexpected();
+  }
+
+  // There is some duplicated information in the serialized format used by
+  // structured clone (since the KeyAlgorithm is serialized separately from the
+  // key data). Use this extra information to further validate what was
+  // deserialized from the key data.
+
+  if (algorithm.id() != key->algorithm().id())
+    return Status::ErrorUnexpected();
+
+  if (key->type() != type)
+    return Status::ErrorUnexpected();
+
+  if (algorithm.rsaHashedParams()->modulusLengthBits() !=
+      key->algorithm().rsaHashedParams()->modulusLengthBits()) {
+    return Status::ErrorUnexpected();
+  }
+
+  if (algorithm.rsaHashedParams()->publicExponent().size() !=
+          key->algorithm().rsaHashedParams()->publicExponent().size() ||
+      0 !=
+          memcmp(algorithm.rsaHashedParams()->publicExponent().data(),
+                 key->algorithm().rsaHashedParams()->publicExponent().data(),
+                 key->algorithm().rsaHashedParams()->publicExponent().size())) {
+    return Status::ErrorUnexpected();
+  }
+
+  return Status::Success();
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ ../components/webcrypto/nss/rsa_hashed_algorithm_nss.h	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,99 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_NSS_RSA_HASHED_ALGORITHM_NSS_H_
+#define COMPONENTS_WEBCRYPTO_NSS_RSA_HASHED_ALGORITHM_NSS_H_
+
+#include <pkcs11t.h>
+
+#include "components/webcrypto/algorithm_implementation.h"
+
+namespace webcrypto {
+
+class PublicKeyNss;
+class PrivateKeyNss;
+
+// Base class for an RSA algorithm whose keys additionaly have a hash parameter
+// bound to them. Provides functionality for generating, importing, and
+// exporting keys.
+class RsaHashedAlgorithm : public AlgorithmImplementation {
+ public:
+  // Constructs an RSA algorithm which will use the NSS flags |generate_flags|
+  // when generating keys. |all_public_key_usages| and |all_private_key_usages|
+  // are the set of WebCrypto key usages that are valid for created keys
+  // (public and private respectively).
+  //
+  // For instance if public keys support encryption and wrapping, and private
+  // keys support decryption and unwrapping callers should set:
+  //    all_public_key_usages = UsageEncrypt | UsageWrap
+  //    all_private_key_usages = UsageDecrypt | UsageUnwrap
+  // This information is used when importing or generating keys, to enforce
+  // that valid key usages are allowed.
+  RsaHashedAlgorithm(CK_FLAGS generate_flags,
+                     blink::WebCryptoKeyUsageMask all_public_key_usages,
+                     blink::WebCryptoKeyUsageMask all_private_key_usages)
+      : generate_flags_(generate_flags),
+        all_public_key_usages_(all_public_key_usages),
+        all_private_key_usages_(all_private_key_usages) {}
+
+  // For instance "RSA-OAEP-256".
+  virtual const char* GetJwkAlgorithm(
+      const blink::WebCryptoAlgorithmId hash) const = 0;
+
+  Status GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                     bool extractable,
+                     blink::WebCryptoKeyUsageMask usages,
+                     GenerateKeyResult* result) const override;
+
+  Status VerifyKeyUsagesBeforeImportKey(
+      blink::WebCryptoKeyFormat format,
+      blink::WebCryptoKeyUsageMask usages) const override;
+
+  Status ImportKeyPkcs8(const CryptoData& key_data,
+                        const blink::WebCryptoAlgorithm& algorithm,
+                        bool extractable,
+                        blink::WebCryptoKeyUsageMask usages,
+                        blink::WebCryptoKey* key) const override;
+
+  Status ImportKeySpki(const CryptoData& key_data,
+                       const blink::WebCryptoAlgorithm& algorithm,
+                       bool extractable,
+                       blink::WebCryptoKeyUsageMask usages,
+                       blink::WebCryptoKey* key) const override;
+
+  Status ExportKeyPkcs8(const blink::WebCryptoKey& key,
+                        std::vector<uint8_t>* buffer) const override;
+
+  Status ExportKeySpki(const blink::WebCryptoKey& key,
+                       std::vector<uint8_t>* buffer) const override;
+
+  Status ImportKeyJwk(const CryptoData& key_data,
+                      const blink::WebCryptoAlgorithm& algorithm,
+                      bool extractable,
+                      blink::WebCryptoKeyUsageMask usages,
+                      blink::WebCryptoKey* key) const override;
+
+  Status ExportKeyJwk(const blink::WebCryptoKey& key,
+                      std::vector<uint8_t>* buffer) const override;
+
+  Status SerializeKeyForClone(
+      const blink::WebCryptoKey& key,
+      blink::WebVector<uint8_t>* key_data) const override;
+
+  Status DeserializeKeyForClone(const blink::WebCryptoKeyAlgorithm& algorithm,
+                                blink::WebCryptoKeyType type,
+                                bool extractable,
+                                blink::WebCryptoKeyUsageMask usages,
+                                const CryptoData& key_data,
+                                blink::WebCryptoKey* key) const override;
+
+ private:
+  const CK_FLAGS generate_flags_;
+  const blink::WebCryptoKeyUsageMask all_public_key_usages_;
+  const blink::WebCryptoKeyUsageMask all_private_key_usages_;
+};
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_NSS_RSA_HASHED_ALGORITHM_NSS_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/rsa_oaep_nss.cc	2016-02-25 14:39:11.027548266 +0000
@@ -0,0 +1,227 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cryptohi.h>
+#include <keyhi.h>
+#include <pk11pub.h>
+#include <secerr.h>
+#include <sechash.h>
+
+#include "base/stl_util.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/rsa_hashed_algorithm_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "third_party/WebKit/public/platform/WebCryptoAlgorithmParams.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+Status NssSupportsRsaOaep() {
+  if (NssRuntimeSupport::Get()->IsRsaOaepSupported())
+    return Status::Success();
+  return Status::ErrorUnsupported(
+      "NSS version doesn't support RSA-OAEP. Try using version 3.16.2 or "
+      "later");
+}
+
+CK_MECHANISM_TYPE WebCryptoHashToMGFMechanism(
+    const blink::WebCryptoAlgorithm& algorithm) {
+  switch (algorithm.id()) {
+    case blink::WebCryptoAlgorithmIdSha1:
+      return CKG_MGF1_SHA1;
+    case blink::WebCryptoAlgorithmIdSha256:
+      return CKG_MGF1_SHA256;
+    case blink::WebCryptoAlgorithmIdSha384:
+      return CKG_MGF1_SHA384;
+    case blink::WebCryptoAlgorithmIdSha512:
+      return CKG_MGF1_SHA512;
+    default:
+      return CKM_INVALID_MECHANISM;
+  }
+}
+
+CK_MECHANISM_TYPE WebCryptoHashToDigestMechanism(
+    const blink::WebCryptoAlgorithm& algorithm) {
+  switch (algorithm.id()) {
+    case blink::WebCryptoAlgorithmIdSha1:
+      return CKM_SHA_1;
+    case blink::WebCryptoAlgorithmIdSha256:
+      return CKM_SHA256;
+    case blink::WebCryptoAlgorithmIdSha384:
+      return CKM_SHA384;
+    case blink::WebCryptoAlgorithmIdSha512:
+      return CKM_SHA512;
+    default:
+      // Not a supported algorithm.
+      return CKM_INVALID_MECHANISM;
+  }
+}
+
+bool InitializeRsaOaepParams(const blink::WebCryptoAlgorithm& hash,
+                             const CryptoData& label,
+                             CK_RSA_PKCS_OAEP_PARAMS* oaep_params) {
+  oaep_params->source = CKZ_DATA_SPECIFIED;
+  oaep_params->pSourceData = const_cast<unsigned char*>(label.bytes());
+  oaep_params->ulSourceDataLen = label.byte_length();
+  oaep_params->mgf = WebCryptoHashToMGFMechanism(hash);
+  oaep_params->hashAlg = WebCryptoHashToDigestMechanism(hash);
+
+  if (oaep_params->mgf == CKM_INVALID_MECHANISM ||
+      oaep_params->hashAlg == CKM_INVALID_MECHANISM) {
+    return false;
+  }
+
+  return true;
+}
+
+Status EncryptRsaOaep(SECKEYPublicKey* key,
+                      const blink::WebCryptoAlgorithm& hash,
+                      const CryptoData& label,
+                      const CryptoData& data,
+                      std::vector<uint8_t>* buffer) {
+  CK_RSA_PKCS_OAEP_PARAMS oaep_params = {0};
+  if (!InitializeRsaOaepParams(hash, label, &oaep_params))
+    return Status::ErrorUnsupported();
+
+  SECItem param;
+  param.type = siBuffer;
+  param.data = reinterpret_cast<unsigned char*>(&oaep_params);
+  param.len = sizeof(oaep_params);
+
+  buffer->resize(SECKEY_PublicKeyStrength(key));
+  unsigned char* buffer_data = buffer->data();
+  unsigned int output_len;
+  if (NssRuntimeSupport::Get()->pk11_pub_encrypt_func()(
+          key, CKM_RSA_PKCS_OAEP, &param, buffer_data, &output_len,
+          buffer->size(), data.bytes(), data.byte_length(),
+          NULL) != SECSuccess) {
+    return Status::OperationError();
+  }
+
+  CHECK_LE(output_len, buffer->size());
+  buffer->resize(output_len);
+  return Status::Success();
+}
+
+Status DecryptRsaOaep(SECKEYPrivateKey* key,
+                      const blink::WebCryptoAlgorithm& hash,
+                      const CryptoData& label,
+                      const CryptoData& data,
+                      std::vector<uint8_t>* buffer) {
+  Status status = NssSupportsRsaOaep();
+  if (status.IsError())
+    return status;
+
+  CK_RSA_PKCS_OAEP_PARAMS oaep_params = {0};
+  if (!InitializeRsaOaepParams(hash, label, &oaep_params))
+    return Status::ErrorUnsupported();
+
+  SECItem param;
+  param.type = siBuffer;
+  param.data = reinterpret_cast<unsigned char*>(&oaep_params);
+  param.len = sizeof(oaep_params);
+
+  const int modulus_length_bytes = PK11_GetPrivateModulusLen(key);
+  if (modulus_length_bytes <= 0)
+    return Status::ErrorUnexpected();
+
+  buffer->resize(modulus_length_bytes);
+
+  unsigned char* buffer_data = buffer->data();
+  unsigned int output_len;
+  if (NssRuntimeSupport::Get()->pk11_priv_decrypt_func()(
+          key, CKM_RSA_PKCS_OAEP, &param, buffer_data, &output_len,
+          buffer->size(), data.bytes(), data.byte_length()) != SECSuccess) {
+    return Status::OperationError();
+  }
+
+  CHECK_LE(output_len, buffer->size());
+  buffer->resize(output_len);
+  return Status::Success();
+}
+
+class RsaOaepImplementation : public RsaHashedAlgorithm {
+ public:
+  RsaOaepImplementation()
+      : RsaHashedAlgorithm(
+            CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP,
+            blink::WebCryptoKeyUsageEncrypt | blink::WebCryptoKeyUsageWrapKey,
+            blink::WebCryptoKeyUsageDecrypt |
+                blink::WebCryptoKeyUsageUnwrapKey) {}
+
+  Status GenerateKey(const blink::WebCryptoAlgorithm& algorithm,
+                     bool extractable,
+                     blink::WebCryptoKeyUsageMask usages,
+                     GenerateKeyResult* result) const override {
+    Status status = NssSupportsRsaOaep();
+    if (status.IsError())
+      return status;
+    return RsaHashedAlgorithm::GenerateKey(algorithm, extractable, usages,
+                                           result);
+  }
+
+  Status VerifyKeyUsagesBeforeImportKey(
+      blink::WebCryptoKeyFormat format,
+      blink::WebCryptoKeyUsageMask usages) const override {
+    Status status = NssSupportsRsaOaep();
+    if (status.IsError())
+      return status;
+    return RsaHashedAlgorithm::VerifyKeyUsagesBeforeImportKey(format, usages);
+  }
+
+  const char* GetJwkAlgorithm(
+      const blink::WebCryptoAlgorithmId hash) const override {
+    switch (hash) {
+      case blink::WebCryptoAlgorithmIdSha1:
+        return "RSA-OAEP";
+      case blink::WebCryptoAlgorithmIdSha256:
+        return "RSA-OAEP-256";
+      case blink::WebCryptoAlgorithmIdSha384:
+        return "RSA-OAEP-384";
+      case blink::WebCryptoAlgorithmIdSha512:
+        return "RSA-OAEP-512";
+      default:
+        return NULL;
+    }
+  }
+
+  Status Encrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    if (key.type() != blink::WebCryptoKeyTypePublic)
+      return Status::ErrorUnexpectedKeyType();
+
+    return EncryptRsaOaep(
+        PublicKeyNss::Cast(key)->key(),
+        key.algorithm().rsaHashedParams()->hash(),
+        CryptoData(algorithm.rsaOaepParams()->optionalLabel()), data, buffer);
+  }
+
+  Status Decrypt(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 const CryptoData& data,
+                 std::vector<uint8_t>* buffer) const override {
+    if (key.type() != blink::WebCryptoKeyTypePrivate)
+      return Status::ErrorUnexpectedKeyType();
+
+    return DecryptRsaOaep(
+        PrivateKeyNss::Cast(key)->key(),
+        key.algorithm().rsaHashedParams()->hash(),
+        CryptoData(algorithm.rsaOaepParams()->optionalLabel()), data, buffer);
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformRsaOaepImplementation() {
+  return new RsaOaepImplementation;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/rsa_ssa_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,133 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <cryptohi.h>
+
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/rsa_hashed_algorithm_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+namespace {
+
+class RsaSsaImplementation : public RsaHashedAlgorithm {
+ public:
+  RsaSsaImplementation()
+      : RsaHashedAlgorithm(CKF_SIGN | CKF_VERIFY,
+                           blink::WebCryptoKeyUsageVerify,
+                           blink::WebCryptoKeyUsageSign) {}
+
+  const char* GetJwkAlgorithm(
+      const blink::WebCryptoAlgorithmId hash) const override {
+    switch (hash) {
+      case blink::WebCryptoAlgorithmIdSha1:
+        return "RS1";
+      case blink::WebCryptoAlgorithmIdSha256:
+        return "RS256";
+      case blink::WebCryptoAlgorithmIdSha384:
+        return "RS384";
+      case blink::WebCryptoAlgorithmIdSha512:
+        return "RS512";
+      default:
+        return NULL;
+    }
+  }
+
+  Status Sign(const blink::WebCryptoAlgorithm& algorithm,
+              const blink::WebCryptoKey& key,
+              const CryptoData& data,
+              std::vector<uint8_t>* buffer) const override {
+    if (key.type() != blink::WebCryptoKeyTypePrivate)
+      return Status::ErrorUnexpectedKeyType();
+
+    SECKEYPrivateKey* private_key = PrivateKeyNss::Cast(key)->key();
+
+    const blink::WebCryptoAlgorithm& hash =
+        key.algorithm().rsaHashedParams()->hash();
+
+    // Pick the NSS signing algorithm by combining RSA-SSA (RSA PKCS1) and the
+    // inner hash of the input Web Crypto algorithm.
+    SECOidTag sign_alg_tag;
+    switch (hash.id()) {
+      case blink::WebCryptoAlgorithmIdSha1:
+        sign_alg_tag = SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION;
+        break;
+      case blink::WebCryptoAlgorithmIdSha256:
+        sign_alg_tag = SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION;
+        break;
+      case blink::WebCryptoAlgorithmIdSha384:
+        sign_alg_tag = SEC_OID_PKCS1_SHA384_WITH_RSA_ENCRYPTION;
+        break;
+      case blink::WebCryptoAlgorithmIdSha512:
+        sign_alg_tag = SEC_OID_PKCS1_SHA512_WITH_RSA_ENCRYPTION;
+        break;
+      default:
+        return Status::ErrorUnsupported();
+    }
+
+    crypto::ScopedSECItem signature_item(SECITEM_AllocItem(NULL, NULL, 0));
+    if (SEC_SignData(signature_item.get(), data.bytes(), data.byte_length(),
+                     private_key, sign_alg_tag) != SECSuccess) {
+      return Status::OperationError();
+    }
+
+    buffer->assign(signature_item->data,
+                   signature_item->data + signature_item->len);
+    return Status::Success();
+  }
+
+  Status Verify(const blink::WebCryptoAlgorithm& algorithm,
+                const blink::WebCryptoKey& key,
+                const CryptoData& signature,
+                const CryptoData& data,
+                bool* signature_match) const override {
+    if (key.type() != blink::WebCryptoKeyTypePublic)
+      return Status::ErrorUnexpectedKeyType();
+
+    SECKEYPublicKey* public_key = PublicKeyNss::Cast(key)->key();
+
+    const blink::WebCryptoAlgorithm& hash =
+        key.algorithm().rsaHashedParams()->hash();
+
+    const SECItem signature_item = MakeSECItemForBuffer(signature);
+
+    SECOidTag hash_alg_tag;
+    switch (hash.id()) {
+      case blink::WebCryptoAlgorithmIdSha1:
+        hash_alg_tag = SEC_OID_SHA1;
+        break;
+      case blink::WebCryptoAlgorithmIdSha256:
+        hash_alg_tag = SEC_OID_SHA256;
+        break;
+      case blink::WebCryptoAlgorithmIdSha384:
+        hash_alg_tag = SEC_OID_SHA384;
+        break;
+      case blink::WebCryptoAlgorithmIdSha512:
+        hash_alg_tag = SEC_OID_SHA512;
+        break;
+      default:
+        return Status::ErrorUnsupported();
+    }
+
+    *signature_match =
+        SECSuccess == VFY_VerifyDataDirect(data.bytes(), data.byte_length(),
+                                           public_key, &signature_item,
+                                           SEC_OID_PKCS1_RSA_ENCRYPTION,
+                                           hash_alg_tag, NULL, NULL);
+    return Status::Success();
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformRsaSsaImplementation() {
+  return new RsaSsaImplementation;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/sha_nss.cc	2016-02-25 14:39:31.619845579 +0000
@@ -0,0 +1,156 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <sechash.h>
+#include <vector>
+
+#include "base/stl_util.h"
+#include "components/webcrypto/algorithm_implementation.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/nss_util.h"
+#include "crypto/scoped_nss_types.h"
+
+namespace webcrypto {
+
+namespace {
+
+HASH_HashType WebCryptoAlgorithmToNSSHashType(
+    blink::WebCryptoAlgorithmId algorithm) {
+  switch (algorithm) {
+    case blink::WebCryptoAlgorithmIdSha1:
+      return HASH_AlgSHA1;
+    case blink::WebCryptoAlgorithmIdSha256:
+      return HASH_AlgSHA256;
+    case blink::WebCryptoAlgorithmIdSha384:
+      return HASH_AlgSHA384;
+    case blink::WebCryptoAlgorithmIdSha512:
+      return HASH_AlgSHA512;
+    default:
+      // Not a digest algorithm.
+      return HASH_AlgNULL;
+  }
+}
+
+// Implementation of blink::WebCryptoDigester, an internal Blink detail not
+// part of WebCrypto, that allows chunks of data to be streamed in before
+// computing a SHA-* digest (as opposed to ShaImplementation, which computes
+// digests over complete messages)
+class DigestorNSS : public blink::WebCryptoDigestor {
+ public:
+  explicit DigestorNSS(blink::WebCryptoAlgorithmId algorithm_id)
+      : hash_context_(NULL), algorithm_id_(algorithm_id) {}
+
+  ~DigestorNSS() override {
+    if (!hash_context_)
+      return;
+
+    HASH_Destroy(hash_context_);
+    hash_context_ = NULL;
+  }
+
+  bool consume(const unsigned char* data, unsigned int size) override {
+    return ConsumeWithStatus(data, size).IsSuccess();
+  }
+
+  Status ConsumeWithStatus(const unsigned char* data, unsigned int size) {
+    // Initialize everything if the object hasn't been initialized yet.
+    if (!hash_context_) {
+      Status error = Init();
+      if (!error.IsSuccess())
+        return error;
+    }
+
+    HASH_Update(hash_context_, data, size);
+
+    return Status::Success();
+  }
+
+  bool finish(unsigned char*& result_data,
+              unsigned int& result_data_size) override {
+    Status error = FinishInternal(result_, &result_data_size);
+    if (!error.IsSuccess())
+      return false;
+    result_data = result_;
+    return true;
+  }
+
+  Status FinishWithVectorAndStatus(std::vector<uint8_t>* result) {
+    if (!hash_context_)
+      return Status::ErrorUnexpected();
+
+    unsigned int result_length = HASH_ResultLenContext(hash_context_);
+    result->resize(result_length);
+    unsigned char* digest = result->data();
+    unsigned int digest_size;  // ignored
+    return FinishInternal(digest, &digest_size);
+  }
+
+ private:
+  Status Init() {
+    HASH_HashType hash_type = WebCryptoAlgorithmToNSSHashType(algorithm_id_);
+
+    if (hash_type == HASH_AlgNULL)
+      return Status::ErrorUnsupported();
+
+    hash_context_ = HASH_Create(hash_type);
+    if (!hash_context_)
+      return Status::OperationError();
+
+    HASH_Begin(hash_context_);
+
+    return Status::Success();
+  }
+
+  Status FinishInternal(unsigned char* result, unsigned int* result_size) {
+    if (!hash_context_) {
+      Status error = Init();
+      if (!error.IsSuccess())
+        return error;
+    }
+
+    unsigned int hash_result_length = HASH_ResultLenContext(hash_context_);
+    DCHECK_LE(hash_result_length, static_cast<size_t>(HASH_LENGTH_MAX));
+
+    HASH_End(hash_context_, result, result_size, hash_result_length);
+
+    if (*result_size != hash_result_length)
+      return Status::ErrorUnexpected();
+    return Status::Success();
+  }
+
+  HASHContext* hash_context_;
+  blink::WebCryptoAlgorithmId algorithm_id_;
+  unsigned char result_[HASH_LENGTH_MAX];
+};
+
+class ShaImplementation : public AlgorithmImplementation {
+ public:
+  Status Digest(const blink::WebCryptoAlgorithm& algorithm,
+                const CryptoData& data,
+                std::vector<uint8_t>* buffer) const override {
+    DigestorNSS digestor(algorithm.id());
+    Status error = digestor.ConsumeWithStatus(data.bytes(), data.byte_length());
+    // http://crbug.com/366427: the spec does not define any other failures for
+    // digest, so none of the subsequent errors are spec compliant.
+    if (!error.IsSuccess())
+      return error;
+    return digestor.FinishWithVectorAndStatus(buffer);
+  }
+};
+
+}  // namespace
+
+AlgorithmImplementation* CreatePlatformShaImplementation() {
+  return new ShaImplementation();
+}
+
+scoped_ptr<blink::WebCryptoDigestor> CreatePlatformDigestor(
+    blink::WebCryptoAlgorithmId algorithm) {
+  return scoped_ptr<blink::WebCryptoDigestor>(new DigestorNSS(algorithm));
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/sym_key_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,76 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/nss/sym_key_nss.h"
+
+#include "base/logging.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/generate_key_result.h"
+#include "components/webcrypto/nss/key_nss.h"
+#include "components/webcrypto/nss/util_nss.h"
+#include "components/webcrypto/status.h"
+#include "components/webcrypto/webcrypto_util.h"
+#include "crypto/scoped_nss_types.h"
+#include "third_party/WebKit/public/platform/WebCryptoKeyAlgorithm.h"
+
+namespace webcrypto {
+
+Status GenerateSecretKeyNss(const blink::WebCryptoKeyAlgorithm& algorithm,
+                            bool extractable,
+                            blink::WebCryptoKeyUsageMask usages,
+                            unsigned int keylen_bits,
+                            CK_MECHANISM_TYPE mechanism,
+                            GenerateKeyResult* result) {
+  DCHECK_NE(CKM_INVALID_MECHANISM, mechanism);
+
+  crypto::ScopedPK11Slot slot(PK11_GetInternalKeySlot());
+  if (!slot)
+    return Status::OperationError();
+
+  std::vector<uint8_t> bytes(NumBitsToBytes(keylen_bits));
+  if (bytes.size() > 0) {
+    if (PK11_GenerateRandom(&bytes[0], bytes.size()) != SECSuccess)
+      return Status::OperationError();
+    TruncateToBitLength(keylen_bits, &bytes);
+  }
+
+  blink::WebCryptoKey key;
+  Status status = ImportKeyRawNss(CryptoData(bytes), algorithm, extractable,
+                                  usages, mechanism, &key);
+  if (status.IsError())
+    return status;
+
+  result->AssignSecretKey(key);
+  return Status::Success();
+}
+
+Status ImportKeyRawNss(const CryptoData& key_data,
+                       const blink::WebCryptoKeyAlgorithm& algorithm,
+                       bool extractable,
+                       blink::WebCryptoKeyUsageMask usages,
+                       CK_MECHANISM_TYPE mechanism,
+                       blink::WebCryptoKey* key) {
+  // The usages are enforced at the WebCrypto layer, so it isn't necessary to
+  // create keys with limited usages.
+  CK_FLAGS flags = kAllOperationFlags;
+
+  DCHECK(!algorithm.isNull());
+  SECItem key_item = MakeSECItemForBuffer(key_data);
+
+  crypto::ScopedPK11Slot slot(PK11_GetInternalSlot());
+  crypto::ScopedPK11SymKey pk11_sym_key(PK11_ImportSymKeyWithFlags(
+      slot.get(), mechanism, PK11_OriginUnwrap, CKA_FLAGS_ONLY, &key_item,
+      flags, false, NULL));
+  if (!pk11_sym_key.get())
+    return Status::OperationError();
+
+  scoped_ptr<SymKeyNss> handle(new SymKeyNss(pk11_sym_key.Pass(), key_data));
+
+  *key = blink::WebCryptoKey::create(handle.release(),
+                                     blink::WebCryptoKeyTypeSecret, extractable,
+                                     algorithm, usages);
+  return Status::Success();
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/sym_key_nss.h	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,34 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_NSS_SYM_KEY_NSS_H_
+#define COMPONENTS_WEBCRYPTO_NSS_SYM_KEY_NSS_H_
+
+#include <pkcs11t.h>
+
+#include "third_party/WebKit/public/platform/WebCrypto.h"
+
+namespace webcrypto {
+
+class CryptoData;
+class GenerateKeyResult;
+class Status;
+
+Status GenerateSecretKeyNss(const blink::WebCryptoKeyAlgorithm& algorithm,
+                            bool extractable,
+                            blink::WebCryptoKeyUsageMask usages,
+                            unsigned int keylen_bits,
+                            CK_MECHANISM_TYPE mechanism,
+                            GenerateKeyResult* result);
+
+Status ImportKeyRawNss(const CryptoData& key_data,
+                       const blink::WebCryptoKeyAlgorithm& algorithm,
+                       bool extractable,
+                       blink::WebCryptoKeyUsageMask usages,
+                       CK_MECHANISM_TYPE mechanism,
+                       blink::WebCryptoKey* key);
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_NSS_SYM_KEY_NSS_H_
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/util_nss.cc	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,113 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "components/webcrypto/nss/util_nss.h"
+
+#include "base/lazy_instance.h"
+#include "components/webcrypto/crypto_data.h"
+#include "components/webcrypto/platform_crypto.h"
+#include "crypto/nss_util.h"
+#include "crypto/scoped_nss_types.h"
+
+#if defined(USE_NSS_CERTS)
+#include <dlfcn.h>
+#include <secoid.h>
+#endif
+
+namespace webcrypto {
+
+namespace {
+base::LazyInstance<NssRuntimeSupport>::Leaky g_nss_runtime_support =
+    LAZY_INSTANCE_INITIALIZER;
+}  // namespace
+
+// Creates a SECItem for the data in |buffer|. This does NOT make a copy, so
+// |buffer| should outlive the SECItem.
+SECItem MakeSECItemForBuffer(const CryptoData& buffer) {
+  SECItem item = {
+      siBuffer,
+      // NSS requires non-const data even though it is just for input.
+      const_cast<unsigned char*>(buffer.bytes()),
+      buffer.byte_length()};
+  return item;
+}
+
+CryptoData SECItemToCryptoData(const SECItem& item) {
+  return CryptoData(item.data, item.len);
+}
+
+NssRuntimeSupport* NssRuntimeSupport::Get() {
+  return &g_nss_runtime_support.Get();
+}
+
+NssRuntimeSupport::NssRuntimeSupport() : internal_slot_does_oaep_(false) {
+#if !defined(USE_NSS_CERTS)
+  // Using a bundled version of NSS that is guaranteed to have this symbol.
+  pk11_encrypt_func_ = PK11_Encrypt;
+  pk11_decrypt_func_ = PK11_Decrypt;
+  pk11_pub_encrypt_func_ = PK11_PubEncrypt;
+  pk11_priv_decrypt_func_ = PK11_PrivDecrypt;
+  internal_slot_does_oaep_ = true;
+#else
+  // Using system NSS libraries and PCKS #11 modules, which may not have the
+  // necessary function (PK11_Encrypt) or mechanism support (CKM_AES_GCM).
+
+  // If PK11_Encrypt() was successfully resolved, then NSS will support
+  // AES-GCM directly. This was introduced in NSS 3.15.
+  pk11_encrypt_func_ = reinterpret_cast<PK11_EncryptDecryptFunction>(
+      dlsym(RTLD_DEFAULT, "PK11_Encrypt"));
+  pk11_decrypt_func_ = reinterpret_cast<PK11_EncryptDecryptFunction>(
+      dlsym(RTLD_DEFAULT, "PK11_Decrypt"));
+
+  // Even though NSS's pk11wrap layer may support
+  // PK11_PubEncrypt/PK11_PubDecrypt (introduced in NSS 3.16.2), it may have
+  // loaded a softoken that does not include OAEP support.
+  pk11_pub_encrypt_func_ = reinterpret_cast<PK11_PubEncryptFunction>(
+      dlsym(RTLD_DEFAULT, "PK11_PubEncrypt"));
+  pk11_priv_decrypt_func_ = reinterpret_cast<PK11_PrivDecryptFunction>(
+      dlsym(RTLD_DEFAULT, "PK11_PrivDecrypt"));
+  if (pk11_priv_decrypt_func_ && pk11_pub_encrypt_func_) {
+    crypto::ScopedPK11Slot slot(PK11_GetInternalKeySlot());
+    internal_slot_does_oaep_ =
+        !!PK11_DoesMechanism(slot.get(), CKM_RSA_PKCS_OAEP);
+  }
+#endif
+}
+
+void PlatformInit() {
+  crypto::EnsureNSSInit();
+}
+
+AlgorithmImplementation* CreatePlatformAesCtrImplementation() {
+  // TODO(eroman): http://crbug.com/399084
+  return NULL;
+}
+
+AlgorithmImplementation* CreatePlatformRsaPssImplementation() {
+  // TODO(eroman): http://crbug.com/399090
+  return NULL;
+}
+
+AlgorithmImplementation* CreatePlatformEcdsaImplementation() {
+  // TODO(eroman): http://crbug.com/399094
+  return NULL;
+}
+
+AlgorithmImplementation* CreatePlatformEcdhImplementation() {
+  // TODO(eroman): http://crbug.com/399093
+  return NULL;
+}
+
+AlgorithmImplementation* CreatePlatformHkdfImplementation() {
+  // HKDF is only being imlemented for BoringSSL.
+  return NULL;
+}
+
+AlgorithmImplementation* CreatePlatformPbkdf2Implementation() {
+  // PBKDF2 will only be implemented for BoringSSL, since the NSS
+  // implementation is being deprecated.
+  return NULL;
+}
+
+}  // namespace webcrypto
--- /dev/null	2016-02-10 20:31:45.722229045 +0000
+++ b/components/webcrypto/nss/util_nss.h	2016-02-25 13:41:16.164373143 +0000
@@ -0,0 +1,112 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef COMPONENTS_WEBCRYPTO_NSS_UTIL_NSS_H_
+#define COMPONENTS_WEBCRYPTO_NSS_UTIL_NSS_H_
+
+#include <keythi.h>
+#include <pkcs11t.h>
+#include <seccomon.h>
+#include <secmodt.h>
+
+#include "base/lazy_instance.h"
+
+namespace webcrypto {
+
+class CryptoData;
+
+SECItem MakeSECItemForBuffer(const CryptoData& buffer);
+enum EncryptOrDecrypt { ENCRYPT, DECRYPT };
+
+CryptoData SECItemToCryptoData(const SECItem& item);
+
+const CK_FLAGS kAllOperationFlags =
+    CKF_ENCRYPT | CKF_DECRYPT | CKF_SIGN | CKF_VERIFY | CKF_WRAP | CKF_UNWRAP;
+
+// Signature for PK11_Encrypt and PK11_Decrypt.
+typedef SECStatus (*PK11_EncryptDecryptFunction)(PK11SymKey*,
+                                                 CK_MECHANISM_TYPE,
+                                                 SECItem*,
+                                                 unsigned char*,
+                                                 unsigned int*,
+                                                 unsigned int,
+                                                 const unsigned char*,
+                                                 unsigned int);
+
+// Signature for PK11_PubEncrypt
+typedef SECStatus (*PK11_PubEncryptFunction)(SECKEYPublicKey*,
+                                             CK_MECHANISM_TYPE,
+                                             SECItem*,
+                                             unsigned char*,
+                                             unsigned int*,
+                                             unsigned int,
+                                             const unsigned char*,
+                                             unsigned int,
+                                             void*);
+
+// Signature for PK11_PrivDecrypt
+typedef SECStatus (*PK11_PrivDecryptFunction)(SECKEYPrivateKey*,
+                                              CK_MECHANISM_TYPE,
+                                              SECItem*,
+                                              unsigned char*,
+                                              unsigned int*,
+                                              unsigned int,
+                                              const unsigned char*,
+                                              unsigned int);
+
+// Singleton that detects whether or not AES-GCM and
+// RSA-OAEP are supported by the version of NSS being used.
+// On non-Linux platforms, Chromium embedders ship with a
+// fixed version of NSS, and these are always available.
+// However, on Linux (and ChromeOS), NSS is provided by the
+// system, and thus not all algorithms may be available
+// or be safe to use.
+class NssRuntimeSupport {
+ public:
+  bool IsAesGcmSupported() const {
+    return pk11_encrypt_func_ && pk11_decrypt_func_;
+  }
+
+  bool IsRsaOaepSupported() const {
+    return pk11_pub_encrypt_func_ && pk11_priv_decrypt_func_ &&
+           internal_slot_does_oaep_;
+  }
+
+  // Returns NULL if unsupported.
+  PK11_EncryptDecryptFunction pk11_encrypt_func() const {
+    return pk11_encrypt_func_;
+  }
+
+  // Returns NULL if unsupported.
+  PK11_EncryptDecryptFunction pk11_decrypt_func() const {
+    return pk11_decrypt_func_;
+  }
+
+  // Returns NULL if unsupported.
+  PK11_PubEncryptFunction pk11_pub_encrypt_func() const {
+    return pk11_pub_encrypt_func_;
+  }
+
+  // Returns NULL if unsupported.
+  PK11_PrivDecryptFunction pk11_priv_decrypt_func() const {
+    return pk11_priv_decrypt_func_;
+  }
+
+  static NssRuntimeSupport* Get();
+
+ private:
+  friend struct base::DefaultLazyInstanceTraits<NssRuntimeSupport>;
+
+  NssRuntimeSupport();
+
+  PK11_EncryptDecryptFunction pk11_encrypt_func_;
+  PK11_EncryptDecryptFunction pk11_decrypt_func_;
+  PK11_PubEncryptFunction pk11_pub_encrypt_func_;
+  PK11_PrivDecryptFunction pk11_priv_decrypt_func_;
+  bool internal_slot_does_oaep_;
+};
+
+}  // namespace webcrypto
+
+#endif  // COMPONENTS_WEBCRYPTO_NSS_UTIL_NSS_H_
